<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TCP与UDP报文头格式]]></title>
    <url>%2F2018%2F12%2F02%2FTCP%E4%B8%8EUDP%E6%8A%A5%E6%96%87%E5%A4%B4%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[TCP和UDP是我们经常使用的数据传输协议 1 TCP报文头部 1.1 相关字段解释 1.1.1 关于八位标记位 2 UDP报文头 3 IP头部 3.1 IP报头参数 首先我们需要知道报文的封装结构 1 TCP报文头部TCP是一个面向连接的、可靠的、字节流传输协议。TCP报文封装在IP报文中的时候，TCP头紧接着IP头。不携带选项的TCP头长20bytes，携带选项的TCP头最长可达60bytes。其中header length字段由4比特构成，最大为15，单位是32比特(32-bit word)，即头长的最大值为15*32 bits = 60bytes，因此上面说携带选项的TCP头长最长为60bytes，基本的不携带参数的只有20byte。下面看到的options选项是省略了可能携带的10行10x32bit= 40byte 1.1 相关字段解释源端口： 发送端应用程序的端口号(16bit)目的端口：接收端的端口号源ip和目的ip不在tcp报文里面，在ip报文里面。序列号(SN)：32位的序列号标志TCP报文中第一个byte在对应方向的传输中对应的字节序号。也叫作SEQ确认号：ACK头长：4bit，包括TCP头大小，指示TCP头的长度，数据从何处开始，最大为15，单位是32bit。保留：4bit，默认是0.标记：8个标记位窗口大小：16位，指示从Ack Number开始还愿意接收多少byte的数据了，当前接收端的接收窗还有多少剩余空间。用于TCP的流量控制校验和：16位。发送端基于数据内容计算一个数值，接收端要与发送端数值结果完全一致，才能证明数据的有效性。紧急指针：指向后面是优先数据的字节。option：最大长度是10*32，必须是32的倍数 1.1.1 关于八位标记位这段直接摘抄自：https://www.cnblogs.com/lshs/p/6038458.htmlCWR(Congestion Window Reduce)：拥塞窗口减少标志被发送主机设置，用来表明它接收到了设置ECE标志的TCP包，发送端通过降低发送窗口的大小来降低发送速率ECE(ECN Echo)：ECN响应标志被用来在TCP3次握手时表明一个TCP端是具备ECN功能的，并且表明接收到的TCP包的IP头部的ECN被设置为11。更多信息请参考RFC793。URG(Urgent)：该标志位置位表示紧急(The urgent pointer) 标志有效。该标志位目前已经很少使用参考后面流量控制和窗口管理部分的介绍。ACK(Acknowledgment)：取值1代表Acknowledgment Number字段有效，这是一个确认的TCP包，取值0则不是确认包。后续文章介绍中当ACK标志位有效的时候我们称呼这个包为ACK包，使 用大写的ACK称呼。PSH(Push)：该标志置位时，一般是表示发送端缓存中已经没有待发送的数据，接收端不将该数据进行队列处理，而是尽可能快将数据转由应用处理。在处理 telnet 或 rlogin 等交互模式的连接 时，该标志总是置位的。RST(Reset)：用于复位相应的TCP连接。通常在发生异常或者错误的时候会触发复位TCP连接。SYN(Synchronize)：同步序列编号(Synchronize Sequence Numbers)有效。该标志仅在三次握手建立TCP连接时有效。它提示TCP连接的服务端检查序列编号，该序列编号为TCP连接初始端(一般是客户端)的初始序列编号。在这里，可以把TCP序列编号看作是一个范围从0到4，294，967，295的32位计数器。通过TCP连接交换的数据中每一个字节都经过序列编号。在TCP报头中的序列编号栏包括了TCP分段中第一个字节的序列编号。类似的后续文章介绍中当这个SYN标志位有效的时候我们称呼这个包为SYN包。FIN(Finish)：带有该标志置位的数据包用来结束一个TCP会话，但对应端口仍处于开放状态，准备接收后续数据。当FIN标志有效的时候我们称呼这个包为FIN包 另外我们一般称呼链路层的发出去的数据包为帧(frame)，称呼网络层发给链路层的数据包为包(packet)，称呼传输层发给网络层的数据包为段(segment)。但是正如我们描述所用，段、包、帧也经常统称为数据包或者数据报文 2 UDP报文头源端口：长度为16位，2个字节。目的端口：长度为16位，2个字节。总长度：长度为16位，2个字节，表示 UDP包头长度 和 数据长度之和。校验和：长度为16位，2个字节。由上述的UDP报文格式可以知道，UDP包头的长度为8个字节。 3 IP头部IP数据包也叫IP报文分组，传输在ISO网络7层结构中的网络层，它由IP报文头和IP报文用户数据组成，IP报文头的长度一般在20到60个字节之间，而一个IP分组的最大长度则不能超过65535个字节。所以IP报其实与TCP的差不多，基本长度都是20byte，最长是60。 3.1 IP报头参数版本：占4位（bit），指IP协议的版本号。目前的主要版本为IPV4，即第4版本号，也有一些教育网和科研机构在使用IPV6。在进行通信时，通信双方的IP协议版本号必须一致，否则无法直接通信。首部长度：占4位（bit），指IP报文头的长度。最大的长度（即4个bit都为1时）为15个长度单位，每个长度单位为4字节（TCP/IP标准，DoubleWord），所以IP协议报文头的最大长度为60个字节，最短为上图所示的20个字节。服务类型：占8位（bit），用来获得更好的服务。其中的前3位表示报文的优先级，后面的几位分别表示要求更低时延、更高的吞吐量、更高的可靠性、更低的路由代价等。对应位为1即有相应要求，为0则不要求。总长度：16位（bit），指报文的总长度。注意这里的单位为字节，而不是4字节，所以一个IP报文的的最大长度为65535个字节。标识（identification）：该字段标记当前分片为第几个分片，在数据报重组时很有用。标志（flag）：该字段用于标记该报文是否为分片（有一些可能不需要分片，或不希望分片），后面是否还有分片（是否是最后一个分片）。片偏移：指当前分片在原数据报（分片前的数据报）中相对于用户数据字段的偏移量，即在原数据报中的相对位置。生存时间：TTL（Time to Live）。该字段表明当前报文还能生存多久。每经过1ms或者一个网关，TTL的值自动减1，当生存时间为0时，报文将被认为目的主机不可到达而丢弃。 使用过Ping 命令的用户应该有印象，在windows中输入ping命令，在返回的结果中即有TTL的数值。协议：该字段指出在上层（网络7层结构或TCP/IP的传输层）使用的协议，可能的协议有UDP、TCP、ICMP、IGMP、IGP等。首部校验和：用于检验IP报文头部在传播的过程中是否出错，主要校验报文头中是否有某一个或几个bit被污染或修改了。源IP地址：32位（bit），4个字节，每一个字节为0～255之间的整数，及我们日常见到的IP地址格式。目的IP地址：32位（bit），4个字节，每一个字节为0～255之间的整数，及我们日常见到的IP地址格式http://www.rosoo.net/a/201409/17083.html]]></content>
      <categories>
        <category>Linux 网络编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c++合成默认构造函数与new关键字带不带括号的分析]]></title>
    <url>%2F2018%2F12%2F02%2Fc-%E5%90%88%E6%88%90%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8Enew%E5%85%B3%E9%94%AE%E5%AD%97%E5%B8%A6%E4%B8%8D%E5%B8%A6%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[声明或定义一个类/对象的时候，会因为类本身的成员结构而会引起不同的构造函数的调用，之前的学习中或多或少有些总结。 全篇总结： 1，声明一个类的时候，不一定是调用了默认构造函数 2,《深度探索c++对象模型》关于默认构造函数的解释 2.1 包含了一个类的对象，这个对象有一个构造函数(包括编译器合成的默认构造函数) 2.2 继承自一些基类，其中某些基类有一个构造函数(包括编译器合成的默认构造函数) 2.3 有一个虚函数，或者继承到了虚函数 2.4 带有虚基类的类 3. new创建一个对象时候带不带小括号的区别 3.1内置类型的new 3.2 自定义类型的new 《c++primer（第五版）》《深度探索c++对象模型》《More Effective C++》三本书中都有总结，自己也简单的理解了下 全篇总结：一，声明一个类对象时，不一定是调用了默认的构造函数；只有在没有任何构造函数且AA xx{}声明的时候，编译器才会对内置类型进行“零值化”；其他情况按照四种情况进行分析二，编译器有四种情况会合成默认的构造函数1.包含了一个类的对象，这个对象有一个构造函数(包括编译器合成的默认构造函数)2.继承自一些基类，其中某些基类有一个构造函数(包括编译器合成的默认构造函数)3.有一个虚函数，或者继承到了虚函数4.有虚基类两种错误的观点：a&gt; 任何类如果没有定义构造函数，则编译器会帮我们合成一个默认构造函数。b&gt; 合成默认构造函数会对类中的每一个数据成员进行初始化。三，new对象的时候带不带括号对于自定义类类型： 如果该类没有定义构造函数（由编译器合成默认构造函数）也没有虚函数，那么class c = new class;将不调用合成的默认构造函数，而class c = new class();则会调用默认构造函数。 如果该类没有定义构造函数（由编译器合成默认构造函数）但有虚函数，那么class c = new class;将不调用合成的默认构造函数；class c = new class()会调用默认构造函数。 如果该类定义了默认构造函数，那么class c = new class;和class c = new class();一样，都会调用默认构造函数。对于内置类型：int a = new int;不会将申请到的int空间初始化，而int a = new int();则会将申请到的int空间初始化为0。 1，声明一个类的时候，不一定是调用了默认构造函数如下：123456789101112131415161718192021class HasExplicitCon&#123;public: HasExplicitCon()&#123;cout&lt;&lt;"显式的定义一个默认构造函数"&lt;&lt;endl; &#125; HasExplicitCon(int a)&#123;cout&lt;&lt;"显式的定义一个有参数默认构造函数"&lt;&lt;endl; &#125; int a;&#125;;int main(int argc, char **argv) &#123; HasExplicitCon hasObject1; HasExplicitCon hasObject2(2); HasExplicitCon hasObject3(); cout&lt;&lt;hasObject1.a&lt;&lt;endl; cout&lt;&lt;hasObject2.a&lt;&lt;endl; //cout&lt;&lt;hasObject3.a&lt;&lt;endl; 编译不通过 return 0;&#125; 结果为：1234显式的定义一个默认构造函数显式的定义一个有参数默认构造函数42136757602016 是的，没看错，结果只输出了两行，因为hasObject3后面跟的是小括号，会引起c++歧义，误以为是定义的一个函数，这点在之前的文章中说过了http://blog.csdn.net/hll174/article/details/78309212。用中括号的话则不会，中括号实际是initializer_list,http://zh.cppreference.com/w/cpp/language/list_initializationstd::initializer_list 对象在这些时候自动构造： 花括号初始化器列表用于列表初始化，包括函数调用列表初始化和赋值表达式花括号初始化器列表被绑定到 auto ，包括在带范围 for 循环中 这里默认构造函数没有对变量a进行初始化，且其在类中没有初始值，new出的对象在堆中，编译器进行初始化的时候是对其进行随机初始化的。所以明显看到定义(也就是我们所说的声明时)，会调用无参的构造函数(默认构造函数)，如果自己定义了则使用自己的，自己没有定义，则因为不满足四种情况，编译器也不会生成合成的默认构造函数，因此值是随机的。这里HasExplicitCon自定义了默认构造函数，但是没有对a进行初始化，因此，a的值还是编译器随机化的，这种随机化的与构造函数无关。a的值是程序的责任，而非编译器的责任，默认构造函数只会执行编译器的责任，这点下面会将具体介绍。而如果隐去所有的默认构造函数，则a的值仍然是随机值，因为这时候编译器也不会生成合成的默认构造函数，其不满足下面要介绍的编译器合成默认构造函数的四种情况。这里又发现一种情况情况1：A a;声明，且有显示的默认构造函数和带参数构造函数12345678910111213141516171819202122232425class HasExplicitCon&#123;public: HasExplicitCon()&#123;cout&lt;&lt;&quot;显式的定义一个默认构造函数&quot;&lt;&lt;endl; &#125; HasExplicitCon(int a)&#123;cout&lt;&lt;&quot;显式的定义一个有参数默认构造函数&quot;&lt;&lt;endl; &#125; char *str; int a;&#125;;int main(int argc, char **argv) &#123; HasExplicitCon hasObject1; if(hasObject1.str)&#123; cout&lt;&lt;&quot;str是非空值&quot;&lt;&lt;endl; cout&lt;&lt;*hasObject1.str&lt;&lt;endl; cout&lt;&lt;hasObject1.a&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;&quot;str是空值&quot;&lt;&lt;endl; cout&lt;&lt;*hasObject1.str&lt;&lt;endl; cout&lt;&lt;hasObject1.a&lt;&lt;endl; &#125; return 0;&#125; 结果为：1234显式的定义一个默认构造函数str是非空值?4213819 调用了显示的默认构造函数，但是没有实例化a和str的值，因为这是程序的责任情况2：A a;声明，无显示的默认构造函数和带参数构造函数也就是把上面情况的构造函数全部去掉，这里只贴结果123str是非空值?4213803 结果相同，但原因不同。不满足四种情况，因此实质是编译器没有为其合成默认的构造函数，因为也就是没有构造函数调用，编译器处理的随机值。情况3：A a{};声明，有显示的默认构造函数和带参数构造函数在情况1的基础上，只将声明改为 HasExplicitCon hasObject1{};，结果为：1234显式的定义一个默认构造函数str是非空值?4213819 调用默认构造函数，但是认为str和a是程序的责任，情况与1相同。情况4：A a{};声明，无显示的默认构造函数和带参数构造函数在情况3的基础上，去掉显示的构造函数，这个时候只输出了1str是空值 然后程序死亡，这里断点看到hasObject1.a的值为0。情况2的时候是没有合成构造函数的，也没有对内置类型进行初始值。而这个时候内置类型的值都被“零化”，因为中括号{}的存在，而中括号本质是initializer_list，显示的构造函数中，编译器对于{}还是和普通的()一样，认为不是编译器的责任，例如情况3；而当没有构造函数的时候，编译器会合成了默认的构造函数且对内置类型的对象进行了初始化，这与initializer_list有很大关系，因此对于初始化的时候initializer_list还需要进一步研究。 2,《深度探索c++对象模型》关于默认构造函数的解释文章：http://blog.csdn.net/ywending/article/details/51096547 https://www.cnblogs.com/QG-whz/p/4676481.html http://blog.csdn.net/cn_wk/article/details/61921566 http://blog.csdn.net/spaceyqy/article/details/22730939 这四篇文章中都有详细的讨论，在此之前，先看看编译器合成的默认构造函数条件。首先，《深度探索c++对象模型》这本书告诉我们有两个误解：a) 任何类如果没有定义构造函数，则编译器会帮我们合成一个默认构造函数。b) 合成默认构造函数会对类中的每一个数据成员进行初始化。以及编译器为我们生成默认构造函数的四种情况： 1.包含了一个类的对象，这个对象有一个构造函数(包括编译器合成的默认构造函数) 2.继承自一些基类，其中某些基类有一个构造函数(包括编译器合成的默认构造函数) 3.有一个虚函数，或者继承到了虚函数 4.有虚基类 2.1 包含了一个类的对象，这个对象有一个构造函数(包括编译器合成的默认构造函数) 看下面这段代码1234567891011121314151617181920212223class Foo&#123;public: Foo()&#123;cout&lt;&lt;"Foo显示定义的默认构造函数"&lt;&lt;endl;&#125;; Foo(int)&#123;&#125;;&#125;;class Bar&#123;public: Foo foo; char *str;&#125;;void f()&#123; Bar bar; if(bar.str)&#123; cout&lt;&lt;"编译器对str进行了默认优化"&lt;&lt;endl; cout&lt;&lt;*bar.str&lt;&lt;endl; &#125;&#125;int main(int argc, char **argv) &#123; f(); return 0;&#125; 我在gcc6.2的平台下结果为;123Foo显示定义的默认构造函数编译器对str进行了默认优化? Bar类没有任何构造函数，含有类成员对象foo,且foo类有默认构造函数(显示自定义的)，因此编译器会为Bar类生成合成的默认构造函数，对变量进行初始化，注意这里编译器生成的默认构造函数首先是扩展构造函数，先调用了基类的默认构造函数对foo进行了初始化，这就是其构造函数扩展规则。同时，编译器生成的默认构造函数初始化只会完成编译器责任的初始化，而不会完成程序责任的初始化，这里的foo对象就是编译器的责任，而str指针则是程序的责任，因此str在这里是一个栈区对象，编译器对其是进行随机值初始化(不同编译平台的处理可能不同)，因此我们需要构造Bar自己的构造函数完成程序的初始化，即对str进行初始化,1Bar()&#123;str=0;&#125; 因此，上面文章作者帮我们总结了合成默认构造函数总是不会初始化类的内置类型及复合类型的数据成员，因为这是程序的责任，我们得分清楚编译器的责任与程序的责任。 另外，这篇文章https://www.cnblogs.com/QG-whz/p/4676481.html“这是不可能的，构造函数是用来负责类对象的初始化的，一个类对象无论如何一定会被初始化，不论是默认初始化，还是值初始化。也就是说，当实例化类对象时，一定会调用构造函数。那也就不存在“需要/不需要”这回事，必然会合成。”这是我们之前普遍的想法，我们看到认为的“类实例化”，其实并没有真正的实例化出来，可能类没有构造函数，编译器也无法合成默认的构造函数，“类实例化”仅仅只是编译器随机化的一个垃圾值，我们的实例化是我们知道或者变量对象按照我们需要的去进行初始值，而不是随机值。没有一定会调构造函数，值被初始化有可能只是编译器的处理而非各种构造函数的处理。 2.2 继承自一些基类，其中某些基类有一个构造函数(包括编译器合成的默认构造函数)这与上面类似，只是这里有构造函数的扩展规则基类默认构造函数(按照基类被声明的顺序先声明优先，多层基类按照上层优先)—&gt;类对象的默认构造函数(按照类对象在类中声明的先后顺序)—&gt;类自身的默认构造函数 2.3 有一个虚函数，或者继承到了虚函数同时还有可能：(1)类声明或继承一个虚函数(2)类派生自一个继承链，其中有一个或更多的虚基类总之这种情况的就是类有虚函数了，因为在编译期会有虚函数表被生成出来，同时还有指向虚函数表的指针vptr被生成出来，vptr需要被初始化才能完成虚机制。这些都是在构造函数中完成的，因此没有构造函数的类会由编译器合成默认的构造函数。因此扩展构造函数的规则就是设置正确的虚函数表地址。 2.4 带有虚基类的类这种典型的虚基类的继承有“菱形继承”，为了让派生类中只有一个虚基类的对象，以前编译器的做法是在派生类的每个虚基类中安插一个指针，所有由引用或指针来存取一个虚基类的操作都可以通过相关指针完成。这个指针也是在类构造期间完成的，因此若类没有任何构造函数，编译器会合成默认的构造函数。同样，扩展构造函数的规则是设置正确的虚基类指针的值。因此需要理解编译器合成默认构造函数的四种情况，同时还得区分编译器初始化的责任与程序初始化的责任。 3. new创建一个对象时候带不带小括号的区别如果不用new创建对象，最好是用{}，而不是()，如上所述。当用()的时候，其实有一些误解。同时上面也介绍了编译器生成默认构造函数的四种情况，这里继续看看new一个对象的区别。我们知道如果直接XX xx;则对象的内存是在栈区；而XX xx =new XX;则是在堆区（这里先忽略带不带括号的事）如果没有默认实例化，那么栈区和堆区的值都是随机初始化的，这种随机性很多时候是对程序有害的。 3.1内置类型的new关于内置类型的new情况，这点没有争议：带了()的时候，在分配内存的时候初始化零值(int的0或者string的0值)；没有带()的时候只分配了内存，其值是随机性的。看下面代码：1234567int main(int argc, char **argv) &#123;int *b=new int[100];for(int i=0;i&lt;100;i++)&#123;cout&lt;&lt;b[i]&lt;&lt;endl;&#125;return 0;&#125; 结果为：1234567183532321838263200...-2147450880-2147450880 而加上()后的结果（建议还是用中括号好，前面小括号很多时候会有意想不到的Bug）1int *b=new int[100]&#123;&#125;; 这样的结果为：1230...0 全都是0，符合默认初始化的预期。 3.2 自定义类型的new对于自定义类型的new，这里貌似不同的博客还是有点分歧，然后自己尝试了下。1234567891011121314151617class A&#123;public: int a;&#125;;int main(int argc, char **argv) &#123; A *a1=new A; A *a2=new A(); cout&lt;&lt;a1-&gt;a&lt;&lt;endl; cout&lt;&lt;a2-&gt;a&lt;&lt;endl; A a3; cout&lt;&lt;a3.a&lt;&lt;endl; return 0;&#125; 结果为：1231746512804213632 只有a2的a值为0，a1和a3的值是随机的。这证实了一点：(1)如果该类没有定义构造函数（由编译器合成默认构造函数）也没有虚函数，那么class c = newclass;将不调用合成的默认构造函数，而class c = new class();则会调用默认构造函数。(2)a1不调用合成的默认构造函数，因此值是随机的；a3也是是因为无法生成合成的默认构造函数，而是随机值。然后文章说 如果该类没有定义构造函数（由编译器合成默认构造函数）但有虚函数，那么class c = new class;和class c = new class();一样，都会调用默认构造函数。 尝试了下只加虚函数，结果为1231848134404213600 仍然是只有()的实例为0，而如果该类定义了默认构造函数，那么class c = new class;和class c = new class();一样，都会调用默认构造函数，这点毫无争议。 因此总结下自定义类型的new时候： 如果该类没有定义构造函数（由编译器合成默认构造函数）也没有虚函数，那么class c = new class;将不调用合成的默认构造函数，而class c = new class();则会调用默认构造函数。 如果该类没有定义构造函数（由编译器合成默认构造函数）但有虚函数，那么class c = new class;将不调用合成的默认构造函数；class c = new class()会调用默认构造函数。 如果该类定义了默认构造函数，那么class c = new class;和class c = new class();一样，都会调用默认构造函数。 另外，这里的new调用默认构造函数的时候，是对内置类型对象进行“零值化”的，这点与第一章和第二章说的非编译器的责任则不初始化，因此值是随机的是存在区别的，注意区分。 后续需要对initializer_list在构造函数初始化的情况进行分析，还有没有调用构造函数且自身没有定义构造函数内存的分配问题还需要学习。]]></content>
      <categories>
        <category>深度探索c++对象模型</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[kafka为什么这么快]]></title>
    <url>%2F2018%2F11%2F25%2Fkafka%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%2F</url>
    <content type="text"><![CDATA[目前kafka是应用比较火的消息队列，都说kafka吞吐量大读写快，那到底是怎么快的。这里记录下不断学习的过程。 1 kafka的架构 2 拓扑结构 3 kafka为什么快 3.1 kafka的生产者 3.1.1 顺序写入 3.1.2 Memory Mapped Files 3.2 kafka消费者的零拷贝 3.2.1 mmap减少拷贝次数 3.2.2 使用sendfile(kafka使用方式) 4 kafka总结 1 kafka的架构相关的术语：Broker：每一个kafka实例（或者说每台kafka服务器节点）就是一个broker，一个broker可以有多个topicTopic：消息根据topic进行归类，topic其本质是一个目录，即将同一主题消息归类到同一个目录Partition：Partititon指物理上的分区，每个topic包含多个partititonProducer：消息生产者，产生的消息将会被发送到某个topicConsumer：消息消费者，消费的消息内容来自某个topicConsumer Group：每个consumer属于consumer group 2 拓扑结构Kafka 通过 Zookeeper 管理集群配置，选举 leader，以及在 Consumer Group 发生变化时进行 rebalance。Producer 使用 push 模式将消息发布到 broker，Consumer 使用 pull 模式从 broker 订阅并消费消息。 3 kafka为什么快kafka是用scala编写的同时支持离线数据和实时数据处理的分布式的、基于发布订阅的消息系统。 3.1 kafka的生产者生产者（producer）是负责向Kafka提交数据的，Kafka会把收到的消息都写入到硬盘中，它绝对不会丢失数据。为了优化写入速度Kafak采用了两个技术，顺序写入和MMFile。 3.1.1 顺序写入因为硬盘是机械结构，每次读写都会寻址→写入，其中寻址是一个“机械动作”，它是最耗时的。所以硬盘最“讨厌”随机I/O，最喜欢顺序I/O。为了提高读写硬盘的速度，Kafka就是使用顺序I/O。上图就展示了Kafka是如何写入数据的，每一个Partition其实都是一个文件，收到消息后Kafka会把数据插入到文件末尾。但是这种顺序写入有个缺点：无法删除。所以Kafka是不会删除数据的，它会把所有的数据都保留下来，每个消费者（Consumer）对每个Topic都有一个offset用来表示读取到了第几条数据。上图中有两个消费者，Consumer1有两个offset分别对应Partition0、Partition1（假设每一个Topic一个Partition）；Consumer2有一个offset对应Partition2。这个offset是由客户端SDK负责保存的，Kafka的Broker完全无视这个东西的存在；一般情况下SDK会把它保存到zookeeper里面。(所以需要给Consumer提供zookeeper的地址)。长时间下去硬盘也会满，针对硬盘的也有两种删除策略：基于时间和基于partition文件大小。 3.1.2 Memory Mapped Files硬盘的IO读写速度是不如内存的，因此即使顺序写磁盘，硬盘的访问速度还是略慢。kafka的数据并不是实时写入硬盘的，它是通过计算机系统的分页存储来利用内存提高IO效率的。Memory Mapped Files(后面简称mmap)也被翻译成内存映射文件，在32位操作系统中一般可以表示4G的数据文件，它的工作原理是直接利用操作系统的Page来实现文件到物理内存的直接映射。完成映射之后你对物理内存的操作会被同步到硬盘上。通过内存映射mmap技术，进程读写内存的时候不需关注内存的大小，因为这时候是读写的虚拟内存。使用这种方式可以获取很大的I/O提升，省去了用户空间到内核空间复制的开销（调用文件的read会把数据先放到内核空间的内存中，然后再复制到用户空间的内存中）。但是也有一个很明显的缺陷——不可靠，写到mmap中的数据并没有被真正的写到硬盘，操作系统会在程序主动调用flush的时候才把数据真正的写到硬盘。Kafka提供了一个参数——producer.type来控制是不是主动flush，如果Kafka写入到mmap之后就立即flush然后再返回Producer叫同步(sync)；写入mmap之后立即返回Producer不调用flush叫异步(async)。在linux中的有函数mmap来实现内存映射，在java中也有mappedbytebuffer类来实现内存映射。关于内存映射可以单独细述。 3.2 kafka消费者的零拷贝消费者读取文件数据，kafka写磁盘文件，通常情况速度应该比内存慢，实际上kafka中关于读取数据有关键技术：Zero Copy首先可用看下传统的数据拷贝(读取)过程：一共产生了四次数据拷贝，即使使用DMA来处理硬件之间的通信，也有两次CPU的数据拷贝过程，同时还有用户态和内核态之间的上下文切换。DMA是一种无序CPU参与就可让外设和系统内存之间进行双向数据传输的硬件机制。实际的数据读取过程，根本没修改文件的任何内容，发生的上下文切换和copy过程都是不必要的，那么最主要的就是不要进入用户态。这里可以讨论下linux的零拷贝的几种做法 3.2.1 mmap减少拷贝次数我们减少拷贝次数的一种方法是调用mmap()来代替read调用：应用程序调用mmap()，磁盘上的数据会通过DMA被拷贝的内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样就不需要把内核缓冲区的内容往用户空间拷贝。应用程序再调用write(),操作系统直接将内核缓冲区的内容拷贝到socket缓冲区中，这一切都发生在内核态，最后，socket缓冲区再把数据发到网卡去。mmap替代read很明显减少了一次拷贝，当拷贝数据量很大时，无疑提升了效率。但是使用mmap是有代价的。当你使用mmap时，你可能会遇到一些隐藏的陷阱。例如，当你的程序map了一个文件，但是当这个文件被另一个进程截断(truncate)时, write系统调用会因为访问非法地址而被SIGBUS信号终止。SIGBUS信号默认会杀死你的进程并产生一个coredump,如果你的服务器这样被中止了，产生不可预期的损失。解决办法：为SIGBUS信号增加信号处理程序 使用文件租借锁 3.2.2 使用sendfile(kafka使用方式)内核2.1版本开始，linux支持使用sendfile来简化操作步骤，kafka也是利用该技术实现零拷贝12#include&lt;sys/sendfile.h&gt;ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count); 参数解释： out_fd：输出文件描述符 in_fd：输入文件描述符 offset：in_fd的偏移值，表示从何处开始读取 count：代表读取的内容大小这里也有一些限制：in_fd指向的文件必须是可以mmap的 out_map必须指向一个套接字这也说明了sendfile的方向是单向的，只能从mmap的文件传输数据到套接字上。所以用户态和内核的数据拷贝传输过程如下：上面过程仍然存在一次拷贝，就是页缓存到socket缓存的拷贝。实际上，我们仅仅需要把缓冲区描述符传到socket缓冲区，再把数据长度传过去，这样DMA控制器直接将页缓存中的数据打包发送到网络中就可以了。所以sendfile系统调用利用DMA引擎将文件内容拷贝到内核缓冲区去，然后将带有文件位置和长度信息的缓冲区描述符添加socket缓冲区去，这一步不会将内核中的数据拷贝到socket缓冲区中，DMA引擎会将内核缓冲区的数据拷贝到协议引擎中去，避免了最后一次拷贝。当然kafka针对数据的读取有两种方式：pull和push。目前实现零拷贝的技术还有很多，比如linux 2.6.17开始支持使用splice系统调用，有兴趣的可以看参考链接。 4 kafka总结总的来说kafka快的原因：mmap技术提高操作磁盘IO速度，写文件是末尾顺序写入，速度快； 读文件sendfile实现零拷贝。 参考链接：https://www.infoq.cn/article/kafka-analysis-part-1 https://toutiao.io/posts/508935/app_preview https://www.jianshu.com/p/fad3339e3448]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[百度开源rpc框架sofa-pbrpc与b-rpc]]></title>
    <url>%2F2018%2F11%2F25%2F%E7%99%BE%E5%BA%A6%E5%BC%80%E6%BA%90rpc%E6%A1%86%E6%9E%B6sofa-pbrpc%E4%B8%8Eb-rpc%2F</url>
    <content type="text"><![CDATA[进程间常见的通信方式有消息队列、RPC、管道通信等，而RPC是目前许多公司中应用较为广泛的一种。]]></content>
      <categories>
        <category>Linux 网络编程</category>
      </categories>
      <tags>
        <tag>网络编程之RPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO多路复用之select、poll、epoll详解]]></title>
    <url>%2F2018%2F11%2F25%2FIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8Bselect%E3%80%81poll%E3%80%81epoll%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[关于IO多路复用，是我们必须掌握的基本知识。 1 select函数 1.1 select函数定义 1.1.1 timeout 1.1.2 fd_set类型的三个集合readfds、writefds、exceptfds 1.1.3 nfds 1.2select函数返回值 1.3 select函数的demo 2 poll函数 2.1 poll函数定义 2.1.1 pollfd类型的fds 2.1.2 nfds 2.1.3 timeout 2.2 poll函数返回值 2.3 poll的demo 3 epoll函数 3.1 epoll_create 3.2 epoll_ctl 3.3 epoll_wait 3.4 通用的epoll代码框架 3.5 从内核源码看epoll 1 select函数I/O多路复用的概念涉及一些基本的I/O模型，Linux中的I/O模型大致有五种： 阻塞式I/O非阻塞式I/OI/O多路复用信号驱动式I/O异步I/O 事实上，前面四种I/O模型都是属于同步式的，意思是实质I/O会阻塞进程。关于具体的某种I/O模型不再赘述，这里只看I/O多路复用中的情况。select函数或者pselect函数允许进程指示内核等待多个事件中的任何一个发生，并只在一个或多个事件发生或经历一段指定的时间后才唤醒它。 1.1 select函数定义从man中查看其函数定义:1234567891011/* According to POSIX.1-2001, POSIX.1-2008 */ #include &lt;sys/select.h&gt;/* According to earlier standards */ #include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt; int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); 根据参考也从最后的参数开始，这里就不比较select与pselect的区别了 1.1.1 timeout表示告知内核等待所指定描述符中的任何一个就绪可花多长时间。意思是select阻塞等待文件描述符变为ready状态的时间间隔。select中timout类型是timeval,pselect的类型是timespec，两者只是事件的细度略有差别。12345678struct timeval &#123;long tv_sec; /* 秒=10^6微秒 */long tv_usec; /* 微秒 */&#125;;struct timespec &#123;long tv_sec; /* 秒=10^9纳秒 */long tv_nsec; /* 纳秒 */&#125;; 所以select将被阻塞直到下面三种情况中的任何一个发生： 一个文件描述符变为ready状态调用被一个信号操作打断timeout参数失效 所以根据调用select时候设置timeout的指，select有三种可能的情况：1）永远等待下去：timeout == NULL,等待可以被一个信号中断。当有一个描述符做好准备或者是捕获到一个信号时函数会返回。 如果捕获到一个信号， select函数将返回-1,并将变量 erro设为 EINTR。2）等待一段固定的时间：timeout-&gt;tv_sec !=0 || timeout-&gt;tv_usec!= 0当有描述符符合条件或者超过超时时间的话，函数返回。在超时时间即将用完但又没有描述符合条件的话，返回 0。对于第一种情况，等待也会被信号所中断3）根本不用等待：timeout-&gt;tv_sec == 0 &amp;&amp;timeout-&gt;tv_usec == 0 加入描述符集的描述符都会被测试，并且返回满足要求的描述符的个数。这种方法通过轮询，无阻塞地获得了多个文件描述符状态 前面两种情况的等待会被进在等待期间捕获的信号中断，并从信号函数返回。在之前的版本中timout参数是const类型，意思是在函数返回时参数不会被select修改。但是现在最新的函数中取消这个限制，于是可修改了。 1.1.2 fd_set类型的三个集合readfds、writefds、exceptfds指定内核测试读、写、异常的三个描述符集合。-&gt;关于描述符集fd_set fd_set是一个固定大小的buffer，通常是一个整数数组，其中每个整数中的每一位对应一个描述符。 例如32位的整数，那么数组index==0位置上的元素对应描述符0~31，类似的数组第二个元素对应描述符31~63。 我们不必关注fd_set的数据类型，具体的操作只需要关注下面的四个宏123456#include &lt;sys/select.h&gt;void FD_CLR(int fd, fd_set *set);//用于在文件描述符集合中删除一个文件描述符int FD_ISSET(int fd, fd_set *set);//用于测试指定的文件描述符是否在该集合中void FD_SET(int fd, fd_set *set);//用于在文件描述符集合中增加一个新的文件描述符void FD_ZERO(fd_set *set); //将set的所有位都清空设为0,在对文件描述符集合进行设置前，必须对其进行初始化 1.1.3 nfdsnfds是三个集合中编号最高的文件描述符+1.头文件中“bits/typesizes.h”中定义了FD_SETSIZE常量1024代表着文件描述符的最大值 1.2select函数返回值成功的时候会返回包含在三个fd_set中的文件描述符数目，这个总的数目是指三个集合中的bit位的计算总和;当然这个总数可能为0当在timeout超时前没有所关注的描述符的事件发生。错误的时候返回-1 1.3 select函数的demo在网上看到一篇介绍select简单原理的图，这里摘过来(注：select 原理图，摘自 IBM iSeries 信息中心)下面是一段简单的代码，没有建立socket，只是关注了fd0的文件描述符，因为没做任何操作，所以会在5s时间过后退出。12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;intmain(void)&#123; fd_set rfds; struct timeval tv; int retval; /* Watch stdin (fd 0) to see when it has input. */ FD_ZERO(&amp;rfds); FD_SET(0, &amp;rfds); //设置关注的描述符集合 /* Wait up to five seconds. */ tv.tv_sec = 5; //5秒的定时 tv.tv_usec = 0; retval = select(1, &amp;rfds, NULL, NULL, &amp;tv); //writefds、exceptfds集合都是空的 /* Don't rely on the value of tv now! */ if (retval == -1) perror("select()"); else if (retval) &#123; printf("Data is available now.\n"); /* FD_ISSET(0, &amp;rfds) will be true. */ if(FD_ISSET(0, &amp;rfds)) &#123; printf("stdin (fd 0) has input \n"); &#125; &#125; else printf("No data within 5 seconds.\n"); exit(EXIT_SUCCESS);&#125; 如果没有任何操作的话12No data within 5 seconds.[Finished in 5.2s] select返回是只是ready描述符的数目，因此需要从0开始去遍历fd_set集合，通过FD_ISSET判断描述符是否是关注的描述符。因此这种方式还是很低效的，这里看到一个例子就不粘贴过来了。https://blog.csdn.net/poechant/article/details/7627894# 2 poll函数poll函数和select函数一样，都是在返回的时候遍历描述符集合来查看描述符是否就绪。 2.1 poll函数定义poll也和select一样有ppoll，这里也不赘述其升级版。12#include &lt;poll.h&gt; int poll(struct pollfd *fds, nfds_t nfds, int timeout); 这里就从前往后看其参数 2.1.1 pollfd类型的fds第一个参数fds是指向一个结构数组第一个元素的指针，也是放的所有被监视的文件描述符集合12345struct pollfd &#123;int fd; /* file descriptor */short events; /* 等待的事件 */short revents; /* 实际发生的事件 */&#125;; 从书上摘抄下events的相应常量值pollfd结构中fd绑定了相应的等待事件与返回事件，与select中的值-结果参数是存在区别的。 2.1.2 nfds用于标记数组fds中的结构体元素的总数量，这里没有select中限制fd数1024的限制，但是一般是unsigned long或者unsigned int，基本属于无限制 2.1.3 timeout这里的timeout是一个int值，与前面的select的timeout类型不同，指定poll返回前需要等待的时间，单位是毫秒(1秒=10^3毫秒)timeout的可能只有三种情况：——–INFTIM 永远等待——–0 立即返回，不阻塞进程——–&gt;0 等待指定数目的毫秒数INFTIM是一个负值，通常是-1; 2.2 poll函数返回值发生错误时，返回-1；定时器时间耗完没有fd就绪，返回0；返回就绪描述符个数。这和select返回值是一样的 2.3 poll的demopoll与select大致相似，根据网上的demo进行一些学习还是创建Server与Client123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/socket.h&gt;#include &lt;poll.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;arpa/inet.h&gt;#define IPADDRESS &quot;127.0.0.1&quot;#define PORT 8787#define MAXLINE 1024#define LISTENQ 5#define OPEN_MAX 1000#define INFTIM -1//函数声明//创建套接字并进行绑定static int socket_bind(const char* ip,int port);//IO多路复用pollstatic void do_poll(int listenfd);//处理多个连接static void handle_connection(struct pollfd *connfds,int num);int main(int argc,char *argv[])&#123;int listenfd,connfd,sockfd;struct sockaddr_in cliaddr;socklen_t cliaddrlen;listenfd = socket_bind(IPADDRESS,PORT);listen(listenfd,LISTENQ);do_poll(listenfd);return 0;&#125;static int socket_bind(const char* ip,int port)&#123;int listenfd;struct sockaddr_in servaddr;listenfd = socket(AF_INET,SOCK_STREAM,0);if (listenfd == -1)&#123;perror(&quot;socket error:&quot;);exit(1);&#125;bzero(&amp;servaddr,sizeof(servaddr));servaddr.sin_family = AF_INET;inet_pton(AF_INET,ip,&amp;servaddr.sin_addr);servaddr.sin_port = htons(port);if (bind(listenfd,(struct sockaddr*)&amp;servaddr,sizeof(servaddr)) == -1)&#123;perror(&quot;bind error: &quot;);exit(1);&#125;return listenfd;&#125;static void do_poll(int listenfd)&#123;int connfd,sockfd;struct sockaddr_in cliaddr;socklen_t cliaddrlen;struct pollfd clientfds[OPEN_MAX];int maxi;int i;int nready;//添加监听描述符clientfds[0].fd = listenfd;clientfds[0].events = POLLIN;//初始化客户连接描述符for (i = 1;i &lt; OPEN_MAX;i++)clientfds[i].fd = -1;maxi = 0;//循环处理for ( ; ; )&#123;//获取可用描述符的个数nready = poll(clientfds,maxi+1,INFTIM);if (nready == -1)&#123;perror(&quot;poll error:&quot;);exit(1);&#125;//测试监听描述符是否准备好if (clientfds[0].revents &amp; POLLIN)&#123;cliaddrlen = sizeof(cliaddr);//接受新的连接if ((connfd = accept(listenfd,(struct sockaddr*)&amp;cliaddr,&amp;cliaddrlen)) == -1)&#123;if (errno == EINTR)continue;else&#123;perror(&quot;accept error:&quot;);exit(1);&#125;&#125;fprintf(stdout,&quot;accept a new client: %s:%d\n&quot;, inet_ntoa(cliaddr.sin_addr),cliaddr.sin_port);//将新的连接描述符添加到数组中for (i = 1;i &lt; OPEN_MAX;i++)&#123;if (clientfds[i].fd &lt; 0)&#123;clientfds[i].fd = connfd;break;&#125;&#125;if (i == OPEN_MAX)&#123;fprintf(stderr,&quot;too many clients.\n&quot;);exit(1);&#125;//将新的描述符添加到读描述符集合中clientfds[i].events = POLLIN;//记录客户连接套接字的个数maxi = (i &gt; maxi ? i : maxi);if (--nready &lt;= 0)continue;&#125;//处理客户连接handle_connection(clientfds,maxi);&#125;&#125;static void handle_connection(struct pollfd *connfds,int num)&#123;int i,n;char buf[MAXLINE];memset(buf,0,MAXLINE);for (i = 1;i &lt;= num;i++)&#123;if (connfds[i].fd &lt; 0)continue;//测试客户描述符是否准备好if (connfds[i].revents &amp; POLLIN)&#123;//接收客户端发送的信息n = read(connfds[i].fd,buf,MAXLINE);if (n == 0)&#123;close(connfds[i].fd);connfds[i].fd = -1;continue;&#125;// printf(&quot;read msg is: &quot;);write(STDOUT_FILENO,buf,n);//向客户端发送bufwrite(connfds[i].fd,buf,n);&#125;&#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;netinet/in.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;poll.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;arpa/inet.h&gt;#define MAXLINE 1024#define IPADDRESS &quot;127.0.0.1&quot;#define SERV_PORT 8787#define max(a,b) (a &gt; b) ? a : bstatic void handle_connection(int sockfd);int main(int argc,char *argv[])&#123;int sockfd;struct sockaddr_in servaddr;sockfd = socket(AF_INET,SOCK_STREAM,0);bzero(&amp;servaddr,sizeof(servaddr));servaddr.sin_family = AF_INET;servaddr.sin_port = htons(SERV_PORT);inet_pton(AF_INET,IPADDRESS,&amp;servaddr.sin_addr);connect(sockfd,(struct sockaddr*)&amp;servaddr,sizeof(servaddr));//处理连接描述符handle_connection(sockfd);return 0;&#125;static void handle_connection(int sockfd)&#123;char sendline[MAXLINE],recvline[MAXLINE];int maxfdp,stdineof;struct pollfd pfds[2];int n;//添加连接描述符pfds[0].fd = sockfd;pfds[0].events = POLLIN;//添加标准输入描述符pfds[1].fd = STDIN_FILENO;pfds[1].events = POLLIN;for (; ;)&#123;poll(pfds,2,-1);if (pfds[0].revents &amp; POLLIN)&#123;n = read(sockfd,recvline,MAXLINE);if (n == 0)&#123;fprintf(stderr,&quot;client: server is closed.\n&quot;);close(sockfd);&#125;write(STDOUT_FILENO,recvline,n);&#125;//测试标准输入是否准备好if (pfds[1].revents &amp; POLLIN)&#123;n = read(STDIN_FILENO,sendline,MAXLINE);if (n == 0)&#123;shutdown(sockfd,SHUT_WR);continue;&#125;write(sockfd,sendline,n);&#125;&#125;&#125; 上面代码中可以看到，针对服务端，还是通过判断poll的返回值，然后去遍历查找pollfd类型的数组，和select是一样的123456789101112//获取可用描述符的个数nready = poll(clientfds,maxi+1,INFTIM);if (nready == -1)&#123;perror("poll error:");exit(1);&#125;//测试监听描述符是否准备好if (clientfds[0].revents &amp; POLLIN)&#123;....&#125; 参考链接：https://www.cnblogs.com/Anker/p/3261006.html https://www.cnblogs.com/zhuwbox/p/4222382.html 3 epoll函数epoll是在内核2.6支持的，我当前的内核版本是4.4.0版本。epoll和poll相似，都是监视多个文件描述符查看其是否就绪，但是epoll有很大的改进。关于epoll的水平触发和边缘触发的工作模式在最后总结。首先，你得包含头文件1#include &lt;sys/epoll.h&gt; epoll调用主要是三个基本函数123int epoll_create(int size);int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); 3.1 epoll_createepoll_create创建一个epoll实例，返回与该实例对应的文件描述符。当该fd不再需要的时候，应该通过close()函数进行关闭。当指向一个epoll实例的全部文件描述符都已关闭时，内核销毁实例并释放关联的资源重用。其定义如下：12#include &lt;sys/epoll.h&gt;int epoll_create(int size); 从Linux 2.6.8后，参数size被忽略，但是必须大于0。 3.2 epoll_ctl12#include &lt;sys/epoll.h&gt;int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); epoll实例对应描述符的控制接口。 epfd epoll_create()的返回值fd，标记epoll实例的fd op 该参数表示相应的动作，该动作的操作对象是第三个参数fd。 op的动作是三个宏： EPOLL_CTL_ADD：在epoll实例epfd上注册目标文件描述符fd，并将event事件与该fd(ˇˍˇ) 相关联 EPOLL_CTL_MOD：更改与目标fd相关联的事件event EPOLL_CTL_MOD：从epoll实例epfd中删除(取消注册)目标文件fd fd 表示需要监听的目标描述符fd event 告诉内核需要监听fd上面的什么事件，参数event的类型是epoll_event，如下 1234567891011typedef union epoll_data &#123;void *ptr;int fd;uint32_t u32;uint64_t u64;&#125; epoll_data_t;struct epoll_event &#123;uint32_t events; /* Epoll events */epoll_data_t data; /* User data variable */&#125;; epoll_event中的events是位掩码，由下面的几个宏组成： EPOLLIN 对应的文件可读read EPOLLOUT 对应的文件可写write EPOLLRDHUP(Linux 2.6.17) 流套接字中使用的对等关闭连接 EPOLLPRI 有紧急的数据可读 EPOLLERR 文件描述符发生错误。epoll_wait会一直等待该事件；因此没必要将其放入events中 EPOLLHUP 对应文件描述符被挂起。和ERR一样，会造成一直等，也没必要放进events中。 EPOLLET 将epoll设置为边缘触发模式，针对水平触发而言的 EPOLLONESHOT 只监听一次，意味着当监听完后，事件从epoll_wait中移出，相关联的文件描述符不可用，若要再次监听需要再次放入epoll监 听队列 EPOLLWAKEUP 用的较少，遇到再详述。 3.3 epoll_wait等待事件的产生12#include &lt;sys/epoll.h&gt;int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); epfd是与epoll实例相关联的fd maxevents告之内核这个events有多大，这个 maxevents的值不能大于创建epoll_create()时的size 参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞） events指向的内存区域包含着可被调用者使用的事件 函数的返回值与上面类似，大于0的值表示已就绪的文件描述符数目 等于0表示定时器超时 -1表示epoll_wait函数发生了错误 3.4 通用的epoll代码框架123456789101112131415161718192021222324252627282930313233343536for( ; ; )&#123;nfds = epoll_wait(epfd,events,20,500);for(i=0;i&lt;nfds;++i)&#123;if(events[i].data.fd==listenfd) //如果是主socket的事件，则表示有新的连接&#123;connfd = accept(listenfd,(sockaddr *)&amp;clientaddr, &amp;clilen); //accept这个连接ev.data.fd=connfd;ev.events=EPOLLIN|EPOLLET;epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&amp;ev); //将新的fd添加到epoll的监听队列中&#125;else if( events[i].events&amp;EPOLLIN ) //接收到数据，读socket&#123;if ( (sockfd = events[i].data.fd) &lt; 0) continue;n = read(sockfd, line, MAXLINE)) &lt; 0 //读ev.data.ptr = md; //md为自定义类型，添加数据ev.events=EPOLLOUT|EPOLLET;epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);//修改标识符，等待下一个循环时发送数据，异步处理的精髓&#125;else if(events[i].events&amp;EPOLLOUT) //有数据待发送，写socket&#123;struct myepoll_data* md = (myepoll_data*)events[i].data.ptr; //取数据sockfd = md-&gt;fd;send( sockfd, md-&gt;ptr, strlen((char*)md-&gt;ptr), 0 ); //发送数据ev.data.fd=sockfd;ev.events=EPOLLIN|EPOLLET;epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev); //修改标识符，等待下一个循环时接收数据&#125;else&#123;//其他情况的处理&#125;&#125;&#125; 当然最开始是创建epoll_create，然后是等待，通过for循环不断的注册需要监听的事件 3.5 从内核源码看epoll]]></content>
      <categories>
        <category>Linux 网络编程</category>
      </categories>
      <tags>
        <tag>网络编程之IO多路复用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络编程中的Proactor和Reactor模式]]></title>
    <url>%2F2018%2F11%2F25%2F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84Proactor%E5%92%8CReactor%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[网络编程中比较常见的设计模式是Proactor和Reactor模式 1 Proactor模式 2 Reactor模式 1 Proactor模式2 Reactor模式]]></content>
      <categories>
        <category>Linux 网络编程</category>
      </categories>
      <tags>
        <tag>网络编程之设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于tcp的简单socket编程]]></title>
    <url>%2F2018%2F06%2F10%2F%E5%9F%BA%E4%BA%8Etcp%E7%9A%84%E7%AE%80%E5%8D%95socket%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[有段时间没有写网络这块的，最近学习下。 1 服务器代码 2 客户端的代码 3 关于socket中的send recv函数 3.1 send函数 3.2 recv函数 这篇帖子上介绍的linux下的基于tcp的socket编程不错，https://www.cnblogs.com/MyLove-Summer/p/5215287.html。这里贴下一个主要的图，一个基于tcp的网络编程的图。这里来一个简单的例子，一个客户端ClientSock，一个服务端ServerSock，服务器这边监听的端口号是20000，让客户端连上服务器后发送数据，服务器收到后打印出来。 1 服务器代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt;#include &lt;sys/socket.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;netinet/in.h&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;cstring&gt;#include &lt;arpa/inet.h&gt;#define SERVER_PORT 20000#define LENGTH_OF_LISTEN_QUEUE 10#define BUFFER_SIZE 255int main(int argc, char const *argv[])&#123;int servfd,clifd;struct sockaddr_in servaddr,cliaddr;if((servfd = socket(AF_INET,SOCK_STREAM, 0)) &lt; 0)&#123;printf("创建服务端socket失败, servfd[%d]", servfd);exit(1);&#125;bzero(&amp;servaddr , sizeof(servaddr));servaddr.sin_family = AF_INET;servaddr.sin_port = htons(SERVER_PORT);servaddr.sin_addr.s_addr =htons(INADDR_ANY);//INADDR_ANY就是指定地址为0.0.0.0if(bind(servfd, (struct sockaddr *)&amp; servaddr, sizeof(servaddr)) &lt; 0)&#123;printf("绑定到端口%d失败 \n", SERVER_PORT);exit(1);&#125;if(listen(servfd, LENGTH_OF_LISTEN_QUEUE)&lt;0)&#123;printf("回调listen失败 \n");exit(1);&#125;while(1)&#123;//服务端一直不退出，除非进程呗杀死char buf[BUFFER_SIZE];long timestamp;socklen_t length = sizeof(cliaddr);//accept是三次握手的服务端clifd = accept(servfd, ( struct sockaddr *) &amp;cliaddr, &amp;length);if(clifd &lt; 0)&#123;printf("回调accept的时候发生错误");break; // 跳出循环&#125;printf("来自客户端的ip:%s,端口号:%d,clifd[%d] \n", inet_ntoa(cliaddr.sin_addr), ntohs(cliaddr.sin_port), clifd);timestamp = time(NULL);int lengthrec = 0;lengthrec = recv(clifd, buf, BUFFER_SIZE, 0);//接受的是clifdif(lengthrec &lt; 0)&#123;printf("接受客户端的消息失败, lengthrec[%d]\n",lengthrec);exit(1);&#125;printf("来自客户端的数据为[%s] \n",buf);//server收到消息后再发一次消息bzero(buf,sizeof(buf));strcpy(buf,"server收到了client的消息，这是给你的ack回复");send(clifd,buf,BUFFER_SIZE,0); //还是刚才的clifdclose(clifd);//关闭客户端的文件描述符&#125;close(servfd);getchar();return 0;&#125; 本地测试的时候，为了不让终端一闪而过，最后加了个getchar()函数，让其停住。 2 客户端的代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;sys/socket.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;netinet/in.h&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;cstring&gt;#include &lt;arpa/inet.h&gt;#define SERVER_PORT 20000#define CLIENT_PORT ((20001+rand())%65536)#define BUFFER_SIZE 255void usage(char *name)&#123;printf("usage:%s ",name);&#125;int main(int argc, char *argv[])&#123;int clifd,length =0;struct sockaddr_in servaddr,cliaddr;socklen_t socklen = sizeof(servaddr);char buf[BUFFER_SIZE];if(argc &lt; 2)&#123;usage(argv[0]);exit(1);&#125;if((clifd =socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)&#123;printf("创建客户端的fd失败\n");exit(1);&#125;srand(time(NULL));bzero(&amp;cliaddr, sizeof(cliaddr));cliaddr.sin_family = AF_INET;cliaddr.sin_port = htons(CLIENT_PORT);cliaddr.sin_addr.s_addr = htons(INADDR_ANY);bzero(&amp;servaddr, sizeof(servaddr));servaddr.sin_family = AF_INET;inet_aton(argv[1], &amp;servaddr.sin_addr);servaddr.sin_port = htons(SERVER_PORT);if(bind(clifd , (struct sockaddr*) &amp;cliaddr, sizeof(cliaddr)) &lt; 0)&#123;printf("绑定到端口%d失败\n", CLIENT_PORT);exit(1);&#125;if( connect(clifd, (struct sockaddr*)&amp;servaddr, socklen) &lt; 0)&#123;printf("不能够连接到%s!\n", argv[1]);exit(1);&#125;strcpy(buf,"是服务器么，我是客户端");send(clifd, buf, BUFFER_SIZE, 0); //clifd绑定的connect,发的话就是这个socketprintf("客户端发送完了,clifd[%d]\n", clifd);bzero(buf,sizeof(buf));recv(clifd,buf,BUFFER_SIZE,0); //接受消息也是同一个clifdprintf("client发完后又收到了server的消息，消息[%s]",buf);close(clifd);getchar();return 0;&#125; linux下还没有安啥ide，就用两个控制台来看可让服务器不关，client端多次运行这里服务器收到了是每次客户端不同的端口号。这样简单实现了一次通信，至于复杂的多次通信包括select poll epoll等可以继续包装。 3 关于socket中的send recv函数在建立socket后收发数据的时候，用到了send() recv()函数，它们的第一个参数都是fd，这里开始看了一些网上各种抄的版本后，发现收不到数据，自己然后看了下源码和man手册1234567891011121314151617181920212223242526272829303132/* Send N bytes of BUF to socket FD. Returns the number sent or -1. This function is a cancellation point and therefore not marked with __THROW. */extern ssize_t send (int __fd, const void *__buf, size_t __n, int __flags);/* Read N bytes into BUF from socket FD. Returns the number read or -1 for errors. This function is a cancellation point and therefore not marked with __THROW. */extern ssize_t recv (int __fd, void *__buf, size_t __n, int __flags);/* Send N bytes of BUF on socket FD to peer at address ADDR (which is ADDR_LEN bytes long). Returns the number sent, or -1 for errors. This function is a cancellation point and therefore not marked with __THROW. */extern ssize_t sendto (int __fd, const void *__buf, size_t __n, int __flags, __CONST_SOCKADDR_ARG __addr, socklen_t __addr_len);/* Read N bytes into BUF through socket FD. If ADDR is not NULL, fill in *ADDR_LEN bytes of it with tha address of the sender, and store the actual size of the address in *ADDR_LEN. Returns the number of bytes read or -1 for errors. This function is a cancellation point and therefore not marked with __THROW. */extern ssize_t recvfrom (int __fd, void *__restrict __buf, size_t __n, int __flags, __SOCKADDR_ARG __addr, socklen_t *__restrict __addr_len); 3.1 send函数1234send(sockfd, buf, len, flags); is equivalent to sendto(sockfd, buf, len, flags, NULL, 0);The argument sockfd is the file descriptor of the sending socket send函数和sendto函数一样，sockfd是发送端的socket描述符。我们这里的例子只是client发数据server，所以是clifd.源码中send是发送n个byte的buf到socket，这个socket就是发送端发送数据前建立的socket。 3.2 recv函数网上的抄的都说第一个参数是指定接受端的套接字描述符。源码解析从socket FD中读n个byte的buf，注意，这里的FD是三次握手建立连接的socket，也就是accept函数返回的socket，我们这里定义的是clifd。针对发送端接收端，其实简单区分不太正确，发送也可接受，主要是看当前的数据socket是哪一条。| 理解清楚send和recv的socket是哪一个就知道fd了 ps&gt;本地测试的时候有时候会发现端口号被占用，例如服务端的端口号20000被占用，查看端口号是否被占用netstat -anp|grep 20000lsof - i:20000杀进程kill -9 pid号ps:关于博客插入图片的参考https://blog.csdn.net/sugar_rainbow/article/details/57415705]]></content>
      <categories>
        <category>Linux 网络编程</category>
      </categories>
      <tags>
        <tag>TCP SOCKET编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS与回溯]]></title>
    <url>%2F2018%2F06%2F03%2FDFS%E4%B8%8E%E5%9B%9E%E6%BA%AF%2F</url>
    <content type="text"><![CDATA[回溯其实属于DFS的一种特殊场景。 1，岛屿的最大面积 2，岛屿数目 3，朋友圈 4，填充封闭区域 5，太平洋和大西洋的水 6，电话号码的字母组合 7，单词搜索 8，二叉树的所有路径 9，全排列 10，全排列|| 11，组合 12，组合总和 13，组合总和|| 14，组合总和III 15，子集 16，子集II 17，分割回文串 18，解数独 19，n皇后 1，岛屿的最大面积给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)示例 1:[[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]]对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。示例 2:[[0,0,0,0,0,0,0,0]]对于上面这个给定的矩阵, 返回 0。注意: 给定的矩阵grid 的长度和宽度都不超过 50来源： https://leetcode-cn.com/problems/max-area-of-island/description/123456789101112131415161718192021int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int i, int j)&#123; if(i&lt;0||i&gt;=grid.size()||j&lt;0||j&gt;=grid[0].size()) return 0; if(!grid[i][j]) return 0; grid[i][j] = 0; return 1+dfs(grid,i,j+1)+dfs(grid,i,j-1)+dfs(grid,i-1,j)+dfs(grid,i+1,j);&#125;int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; /** 深度遍历dfs */ if(grid.size()==0) return 0; int result =0; for(int i =0;i&lt;grid.size();i++) for(int j=0;j&lt;grid[0].size();j++) if(grid[i][j]) result=max(result,dfs(grid,i,j)); return result;&#125; 2，岛屿数目这题与上一题不同，这个是求岛屿的个数，而不是最大的岛屿面积11110110101100000000Answer: 1123456789101112131415161718192021222324252627void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int i, int j)&#123; if(i&lt;0||i&gt;=grid.size()||j&lt;0||j&gt;=grid[0].size()) return ; if(grid[i][j]=='0') return ; grid[i][j] = '0'; dfs(grid,i,j+1); dfs(grid,i,j-1); dfs(grid,i+1,j); dfs(grid,i-1,j);&#125;int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;/**与求最大的岛屿面积不同，不用做max比较，这个是直接计算岛屿数目*/ if(grid.empty()) return 0; int result =0; for(int i =0;i&lt;grid.size();i++) for(int j=0;j&lt;grid[0].size();j++) if(grid[i][j]=='1') &#123; dfs(grid, i , j); ++result; &#125; return result;&#125; 3，朋友圈班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。示例 1:输入:[[1,1,0], [1,1,0], [0,0,1]]输出: 2说明：已知学生0和学生1互为朋友，他们在一个朋友圈。第2个学生自己在一个朋友圈。所以返回2。示例 2:输入:[[1,1,0], [1,1,1], [0,1,1]]输出: 1说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。注意：N 在[1,200]的范围内。对于所有学生，有M[i][i] = 1。如果有M[i][j] = 1，则有M[j][i] = 1。来源： https://leetcode-cn.com/problems/friend-circles/description/123456789101112131415161718192021222324252627282930void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; M, int k, vector&lt;int&gt;&amp; flag)&#123; if(k&lt;0||k&gt;=M.size()) return; if(flag[k]) return; flag[k]=1; for(int i=0;i&lt;M.size();i++) if(!flag[i]&amp;&amp;M[k][i]) &#123; dfs(M,i,flag);//这里其实不需要上下左右，把当前的处理好就行 &#125;&#125;int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123; /** 这种互为关系的情况，应该是降为一维的; 与求岛屿数目类似 同时增加相应的标记位 */ if(M.empty()) return 0; int result =0; vector&lt;int&gt; flag(M.size(), 0); for(int i= 0;i&lt;M.size();i++) if(!flag[i]) &#123; dfs(M,i,flag); result++; &#125; return result;&#125; 4，填充封闭区域给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。示例:X X X XX O O XX X O XX O X X运行你的函数后，矩阵变为：X X X XX X X XX X X XX O X X解释:被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。来源： https://leetcode-cn.com/problems/surrounded-regions/description/12345678910111213141516171819202122232425262728293031323334void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board,int i,int j) &#123; if(i&lt;0||i&gt;=board.size()||j&lt;0||j&gt;=board[0].size()||board[i][j]!='O') return; board[i][j] ='H'; dfs(board,i+1,j); dfs(board,i-1,j); dfs(board,i,j+1); dfs(board,i,j-1); &#125; void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; /** 找到与边缘相联通的区域，作为标记，剩下的非与边缘相连的O最后转为X */ if(board.empty()) return; for(int i=0;i&lt;board.size();i++) &#123; dfs(board,i,0); dfs(board,i,board[0].size()-1); &#125; for(int j=0;j&lt;board[0].size();j++) &#123; dfs(board,0,j); dfs(board,board.size()-1, j); &#125; for(int i=0;i&lt;board.size();i++) for(int j=0;j&lt;board[0].size();j++) &#123; if(board[i][j]=='O') board[i][j]='X'; else if(board[i][j]=='H') board[i][j]='O'; &#125; &#125; 5，太平洋和大西洋的水Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the “Pacific ocean” touches the left and top edges of the matrix and the “Atlantic ocean” touches the right and bottom edges.Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.Note:The order of returned grid coordinates does not matter.Both m and n are less than 150.Example:Given the following 5x5 matrix: Pacific ~ ~ ~ ~ ~ ~ 1 2 2 3 (5) ~ 3 2 3 (4) (4) ~ 2 4 (5) 3 1 ~ (6) (7) 1 4 5 ~ (5) 1 1 2 4 * * * * * * Atlantic Return:[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).12345678910111213141516171819202122232425262728293031323334353637383940void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; matrix,int i ,int j, vector&lt;vector&lt;int&gt;&gt;&amp; flag)&#123; if(i&lt;0||i&gt;=matrix.size()||j&lt;0||j&gt;=matrix[0].size()||flag[i][j]) return; flag[i][j]=1; if(i+1&lt;matrix.size()&amp;&amp;matrix[i][j]&lt;=matrix[i+1][j]) dfs(matrix,i+1,j,flag); if(i-1&gt;=0&amp;&amp;matrix[i][j]&lt;=matrix[i-1][j]) dfs(matrix,i-1,j,flag); if(j-1&gt;=0&amp;&amp;matrix[i][j]&lt;=matrix[i][j-1]) dfs(matrix,i,j-1,flag); if(j+1&lt;matrix[0].size()&amp;&amp;matrix[i][j]&lt;=matrix[i][j+1]) dfs(matrix,i,j+1,flag);&#125;vector&lt;pair&lt;int, int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; /** 要能流水，则从外到里是增加的 能流到外面，则从外面开始找连通到里面的区域，且是递增 两者都能流，则取交集 */ vector&lt;pair&lt;int, int&gt;&gt; result; if(matrix.empty()) return result; vector&lt;vector&lt;int&gt;&gt; pflag(matrix.size(),vector&lt;int&gt;(matrix[0].size(),0)); vector&lt;vector&lt;int&gt;&gt; aflag(matrix.size(),vector&lt;int&gt;(matrix[0].size(),0)); for(int i=0;i&lt;matrix.size();i++) &#123; dfs(matrix,i,0,pflag); dfs(matrix,i,matrix[0].size()-1,aflag); &#125; for(int j=0;j&lt;matrix[0].size();j++) &#123; dfs(matrix,0,j,pflag); dfs(matrix,matrix.size()-1,j,aflag); &#125; for(int i=0;i&lt;matrix.size();i++) for(int j=0;j&lt;matrix[0].size();j++) if(pflag[i][j]&amp;&amp;aflag[i][j]) result.push_back(make_pair(i,j)); return result;&#125; 关于回溯，是dfs的一种，不同的是在dfs的时候发现不满足条件会回退遍历 6，电话号码的字母组合给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。示例:输入：”23”输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].说明:尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。123456789101112131415161718192021222324252627//0 1不对应数字vector&lt;string&gt; letters=&#123;" "," ","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"&#125;;void dfs(vector&lt;string&gt;&amp; result, string digits, string temp, int curr)&#123; if(curr == digits.size()) &#123; result.push_back(temp); return; &#125; for(int i=0;i&lt;letters[digits[curr]-'0'].size();i++) &#123; temp.push_back(letters[digits[curr]-'0'][i]); dfs(result, digits, temp, curr+1); temp.pop_back(); &#125;&#125;vector&lt;string&gt; letterCombinations(string digits) &#123;/**根据数字映射遍历*/ vector&lt;string&gt; result; if(digits.empty()) return result; string temp; dfs(result,digits,temp,0); return result;&#125; ###ip地址空着 ## 7，单词搜索给定一个二维网格和一个单词，找出该单词是否存在于网格中。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。示例:board =[ [‘A’,’B’,’C’,’E’], [‘S’,’F’,’C’,’S’], [‘A’,’D’,’E’,’E’]]给定 word = “ABCCED”, 返回 true.给定 word = “SEE”, 返回 true.给定 word = “ABCB”, 返回 false.来源： https://leetcode-cn.com/problems/word-search/description/12345678910111213141516171819202122232425262728bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word,vector&lt;vector&lt;int&gt;&gt;&amp; flag, int i, int j, int curr)&#123; if(curr == word.size()) return true; if(i&lt;0||i&gt;=board.size()||j&lt;0||j&gt;=board[0].size()||flag[i][j]==1||board[i][j]!=word[curr]) return false; flag[i][j] =1; if(dfs(board,word,flag,i+1,j,curr+1)|| dfs(board,word,flag,i-1,j,curr+1)|| dfs(board,word,flag,i,j+1,curr+1)|| dfs(board,word,flag,i,j-1,curr+1)) return true; flag[i][j] =0; return false;&#125;bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; /** 典型的回溯,访问路径需要标记*/ if(board.empty()) return false; if(word.empty()) return true; vector&lt;vector&lt;int&gt;&gt; flag(board.size(), vector&lt;int&gt;(board[0].size(), 0)); for(int i=0;i&lt;board.size();i++) for(int j=0;j&lt;board[0].size();j++) if(dfs(board, word,flag, i,j,0)) return true; return false;&#125; 8，二叉树的所有路径这种求所有路径的问题，通过dfs加回溯可以遍历到所有的路径给定一个二叉树，返回从根节点到叶节点的所有路径。例如，给定以下二叉树: 1 / \2 3 \ 5所有根到叶路径是: [“1-&gt;2-&gt;5”, “1-&gt;3”]123456789101112131415161718192021222324252627void dfs(TreeNode* root,vector&lt;string&gt;&amp; result, string path)&#123; if(root==NULL) return; if(root-&gt;left==NULL&amp;&amp;root-&gt;right==NULL) &#123; path+=to_string(root-&gt;val); //这里关于字符串拼接的时候遇到一些以前Java没有遇到的问题 result.push_back(path); return; &#125; path+=to_string(root-&gt;val); path+="-&gt;"; dfs(root-&gt;left,result,path); dfs(root-&gt;right,result,path); path.pop_back();&#125;vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;/**dfs加回溯可以深度遍历到所有的路径*/ vector&lt;string&gt; result; if(root==NULL) return result; string path; dfs(root,result,path); return result;&#125; 9，全排列排列和组合一直都是dfs回溯的经典类型本题是一个没有重复数字的简单版本，这里用swap版本的和一般的不用swap的回溯实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 /** void swap(int &amp;a, int &amp;b) &#123; int temp =a; a = b; b= temp; &#125; void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt; nums,int curr) &#123; if(curr ==nums.size()) &#123; result.push_back(nums); return; &#125; for(int i= curr;i&lt;nums.size();i++)&#123; swap(nums[i], nums[curr]); dfs(result,nums,curr+1); swap(nums[i], nums[curr]); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; /** 排列组合一直是dfs回溯的经典题型 题目说了是没有重复的数字进行全排列，所以这是一个不需要去重复的版本 *//* vector&lt;vector&lt;int&gt;&gt; result; if(nums.empty()) return result; dfs(result,nums,0); return result; &#125;*/ void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt; nums,vector&lt;int&gt; temp,vector&lt;int&gt;&amp; flag) &#123; if(temp.size() ==nums.size()) &#123; result.push_back(temp); return; &#125; for(int i= 0;i&lt;nums.size();i++) &#123; if(flag[i]) continue; flag[i] =1; temp.push_back(nums[i]); dfs(result,nums,temp,flag); temp.pop_back(); flag[i]=0; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; /** 排列组合一直是dfs回溯的经典题型 */ vector&lt;vector&lt;int&gt;&gt; result; if(nums.empty()) return result; vector&lt;int&gt; temp; vector&lt;int&gt; flag(nums.size(),0);//不swap的时候需要标记位 dfs(result,nums,temp,flag); return result; &#125; 10，全排列||给定一个可包含重复数字的序列，返回所有不重复的全排列。示例:输入: [1,1,2]输出:[ [1,1,2], [1,2,1], [2,1,1]]这题与上面不同之处在于原始数据可能有重复的数字这题遇到一些小坑：1，关于要不要引号的问题，如果是没有重复数字，加不加引号测试都没影响， 但是有重复数字的时候： &gt;如果是swap方法，则一定不能用第二次swap且不能要引号，且一定要排序； &gt;一般dfs的话，一定要排序，123456789101112131415161718192021222324252627282930313233 /*void swaps(int&amp; a, int&amp; b)//std中有swap函数&#123; int temp =a; a=b; b=temp;&#125;//void swapdfs(vector&lt;int&gt; nums, vector&lt;vector&lt;int&gt;&gt;&amp; result, int curr)//nums不要加&amp;，这里卡了好久&#123; if(curr &gt;= nums.size()) &#123; result.push_back(nums); return; &#125; for(int i=curr;i&lt;nums.size();i++) &#123; if(i&gt;curr&amp;&amp;nums[i]==nums[curr]) continue; swaps(nums[i],nums[curr]); swapdfs(nums,result,curr+1); //swaps(nums[i],nums[curr]); 一定不能要第二次swap &#125;&#125;vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; result; if(nums.empty()) return result; sort(nums.begin(),nums.end());//排序不可少 swapdfs(nums,result,0); return result;&#125;*/ 再看看非swap方式的123456789101112131415161718192021222324252627282930void swapdfs1(vector&lt;int&gt; nums, vector&lt;vector&lt;int&gt;&gt;&amp; result,vector&lt;int&gt;&amp; flag,vector&lt;int&gt; temp)&#123; if(temp.size() &gt;= nums.size()) &#123; result.push_back(temp); return; &#125; for(int i=0;i&lt;nums.size();i++) &#123; if(i&gt;0&amp;&amp;nums[i]==nums[i-1]&amp;&amp;!flag[i-1]) continue; if(flag[i]) continue; flag[i] =1; temp.push_back(nums[i]); swapdfs1(nums,result,flag,temp); temp.pop_back(); flag[i] =0; &#125;&#125;vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; result; if(nums.empty()) return result; sort(nums.begin(),nums.end());//排序不可少 vector&lt;int&gt; flag(nums.size(),0); vector&lt;int&gt; temp; swapdfs1(nums,result,flag,temp); return result;&#125; 11，组合给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。示例:输入: n = 4, k = 2输出:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],]这题是简答的组合，不需要组合12345678910111213141516171819202122232425void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt; temp,int curr, int n ,int k)&#123; if(k==0) &#123; result.push_back(temp); return; &#125; for(int i=curr;i&lt;=n;i++) &#123; temp.push_back(i); dfs(result,temp,i+1,n,k-1); temp.pop_back(); &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;/**组合的话，也是和排列一样用经典的dfs，不需要用swap之类的*/ vector&lt;vector&lt;int&gt;&gt; result; if(n&lt;=0||k&lt;=0) return result; vector&lt;int&gt; temp; dfs(result,temp,1,n,k); return result;&#125; 12，组合总和给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的数字可以无限制重复被选取说明：所有数字（包括 target）都是正整数。解集不能包含重复的组合。示例 1:given candidate set [2, 3, 6, 7] and target 7,A solution set is:[[7],[2, 2, 3]]given candidate set [2, 3, 5] and target 8,A solution set is:[[2,2,2,2],[2, 3, 3],[3,5]]这里是组合内可由重复数字，因此下次dfs是从i开始不是i+1123456789101112131415161718192021222324252627282930void dfs(vector&lt;int&gt; candidates, vector&lt;vector&lt;int&gt;&gt;&amp; result,vector&lt;int&gt; temp, int target, int curr)&#123; if(target==0) &#123; result.push_back(temp); return; &#125; if(curr&gt;=candidates.size()) return; for(int i=curr;i&lt;candidates.size();i++) &#123; if(target&gt;=candidates[i])//记得判断这个，不然下面的i会死循环 &#123; temp.push_back(candidates[i]); dfs(candidates,result,temp,target-candidates[i],i); temp.pop_back(); &#125; &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; /** dfs回溯*/vector&lt;vector&lt;int&gt;&gt; result; if(candidates.empty()) return result; vector&lt;int&gt; temp; dfs(candidates,result,temp,target,0); return result;&#125; 13，组合总和||给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的每个数字在每个组合中只能使用一次。说明：所有数字（包括目标数）都是正整数。解集不能包含重复的组合。示例 1:given candidate set [10,1,2,7,6,1,5] and target 8,A solution set is:[[1,7],[1, 2, 5],[2,6],[1,1,6]] given candidate set [2,5, 2, 1,2] and target 7,A solution set is:[[7],[2, 2, 3]]123456789101112131415161718192021222324252627282930void dfs(vector&lt;int&gt;&amp; candidates, vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt; temp,int curr, int target)&#123; if(target==0) &#123; result.push_back(temp); return; &#125; for(int i=curr;i&lt;candidates.size();i++) &#123; if(target&gt;=candidates[i]) &#123; temp.push_back(candidates[i]); dfs(candidates,result,temp,i+1,target-candidates[i]); temp.pop_back(); while(i+1&lt;candidates.size()&amp;&amp;candidates[i]==candidates[i+1]) i++;//做递归的重复，这里用来消除重复，当然前面是得排完序的 &#125; &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; /** 这题与组合I不同的在于这里的数字不能重复，建议可以排序下 */ vector&lt;vector&lt;int&gt;&gt; result; if(candidates.empty()) return result; sort(candidates.begin(), candidates.end()); vector&lt;int&gt; temp; dfs(candidates,result,temp,0,target); return result;&#125; 14，组合总和III找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有1 - 9的正整数，并且每种组合中不存在重复的数字。说明：所有数字都是正整数。解集不能包含重复的组合。示例 1:输入： k=3, n=7输出：[[1,2,4]]输入： k=3, n=9输出：[[1,2,6],[1,3,5],[2,3,4]]123456789101112131415161718192021222324252627void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt; temp, int k,int n,int curr)&#123; if(k==temp.size()&amp;&amp;n==0) &#123; result.push_back(temp); return; &#125; if(n&lt;0) return; for(int i=curr;i&lt;=9;i++) &#123; temp.push_back(i); dfs(result,temp,k,n-i,i+1); temp.pop_back(); &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123; /** 这题和最开始的组合差不多，多了个n*/ vector&lt;vector&lt;int&gt;&gt; result; if(n&lt;=0||k&lt;=0) return result; vector&lt;int&gt; temp; dfs(result,temp,k,n,1); return result;&#125; 15，子集给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。示例:输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []]1234567891011121314151617181920212223242526void dfs(vector&lt;int&gt; nums, vector&lt;vector&lt;int&gt;&gt;&amp; result,vector&lt;int&gt; temp,int len, int curr)&#123; if(temp.size()==len) &#123; result.push_back(temp); return; &#125; for(int i=curr;i&lt;nums.size();i++) &#123; temp.push_back(nums[i]); dfs(nums,result,temp,len,i+1); temp.pop_back(); &#125;&#125;vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; /** 子集就是不重复的组合 */ vector&lt;vector&lt;int&gt;&gt; result; if(nums.empty()) return result; vector&lt;int&gt; temp; for(int i=0;i&lt;=nums.size();i++) dfs(nums,result,temp,i,0); return result;&#125; 16，子集II给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。示例:输入: [1,2,2]输出:[ [2], [1], [1,2,2], [2,2], [1,2], []]12345678910111213141516171819202122232425262728void dfs(vector&lt;int&gt; nums, vector&lt;vector&lt;int&gt;&gt;&amp; result,vector&lt;int&gt; temp,int len, int curr)&#123; if(temp.size()==len) &#123; result.push_back(temp); return; &#125; for(int i=curr;i&lt;nums.size();i++) &#123; temp.push_back(nums[i]); dfs(nums,result,temp,len,i+1); temp.pop_back(); while(i+1&lt;nums.size()&amp;&amp;nums[i]==nums[i+1]) i++;//专门去重复的，前提是排序了的 &#125;&#125;vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;/**这题和上面不同之处在于nums中是有重复的*/ vector&lt;vector&lt;int&gt;&gt; result; if(nums.empty()) return result; vector&lt;int&gt; temp; sort(nums.begin(), nums.end()); for(int i=0;i&lt;=nums.size();i++) dfs(nums,result,temp,i,0); return result;&#125; 17，分割回文串给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。返回 s 所有可能的分割方案。示例:输入: “aab”输出:[ [“aa”,”b”], [“a”,”a”,”b”]]123456789101112131415161718192021222324252627282930313233343536373839 vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;bool huiwen(string s,int left,int right) &#123; while(left&lt;right) &#123; if(s[left++]!=s[right--]) return false; &#125; return true; &#125; void dfs(string s,vector&lt;vector&lt;string&gt;&gt;&amp; result,vector&lt;string&gt; temp,int curr) &#123; if(curr == s.size()) &#123; result.push_back(temp); return; &#125; for(int i=curr;i&lt;s.size();i++) &#123; if(huiwen(s,curr,i)) &#123; temp.push_back(s.substr(curr,i-curr+1)); dfs(s,result,temp,i+1); temp.pop_back(); &#125; &#125; &#125; vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123; /** 基本的遍历 */ vector&lt;vector&lt;string&gt;&gt; result; if(s.empty()) return result; vector&lt;string&gt; temp; dfs(s,result,temp,0); return result; &#125; &#125; 18，解数独编写一个程序，通过已填充的空格来解决数独问题。一个数独的解法需遵循如下规则：数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。空白格用 ‘.’ 表示。一个数独。答案被标成红色。Note:给定的数独序列只包含数字 1-9 和字符 ‘.’ 。你可以假设给定的数独只有唯一解。给定数独永远是 9x9 形式来源： https://leetcode-cn.com/problems/sudoku-solver/description/123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board,vector&lt;vector&lt;int&gt;&gt;&amp; row,vector&lt;vector&lt;int&gt;&gt;&amp; col,vector&lt;vector&lt;int&gt;&gt;&amp; grid)&#123; for(int i=0;i&lt;board.size();i++) &#123; for(int j=0;j&lt;board[0].size();j++) &#123; if(board[i][j]=='.') &#123; for(int val =1;val&lt;=9;val++) &#123; if(!row[i][val-1]&amp;&amp;!col[val-1][j]&amp;&amp;!grid[i/3*3+j/3][val-1]) &#123; board[i][j] = val+'0'; row[i][val-1]=1; col[val-1][j]=1; grid[i/3*3+j/3][val-1]=1; if(dfs(board,row,col,grid)) return true; board[i][j] ='.'; row[i][val-1]=0; col[val-1][j]=0; grid[i/3*3+j/3][val-1]=0; &#125; &#125; return false; &#125; &#125; &#125; return true;&#125;void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;/**dfs加标记位*/ vector&lt;vector&lt;int&gt;&gt; row(board.size(),vector&lt;int&gt;(board[0].size(),0)); vector&lt;vector&lt;int&gt;&gt; col(board.size(),vector&lt;int&gt;(board[0].size(),0)); vector&lt;vector&lt;int&gt;&gt; grid(board.size(),vector&lt;int&gt;(board[0].size(),0)); for(int i=0;i&lt;board.size();i++) &#123; for(int j=0;j&lt;board[0].size();j++) &#123; if(board[i][j]=='.') continue; int val = board[i][j] - '0'; row[i][val-1]=1; col[val-1][j]=1; grid[i/3*3+j/3][val-1]=1; &#125; &#125; dfs(board,row,col,grid);&#125; 19，n皇后n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。上图为 8 皇后问题的一种解法。给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556bool check(vector&lt;int&gt;&amp; place, int curr,int val)&#123; for(int i=0;i&lt;curr;i++) &#123; if(place[i]==val||std::abs(i-curr)==std::abs(place[i]-val)) return false; &#125; return true;&#125;void dfs(vector&lt;vector&lt;string&gt;&gt;&amp; result, vector&lt;int&gt;&amp; place, int n,int curr)&#123; if(curr ==n) &#123; vector&lt;string&gt; temp; for(int row =0;row&lt;n;row++) &#123; string tempStr; for(int col =0;col&lt;n;col++) &#123; if(place[row]==col) &#123; tempStr.push_back('Q'); &#125; else &#123; tempStr.push_back('.'); &#125; &#125; temp.push_back(tempStr); &#125; result.push_back(temp); return; &#125; for(int val =0;val&lt;n;val++) &#123; place[curr] = val; if(check(place,curr,val)) dfs(result,place,n,curr+1); place[curr] = -1; &#125;&#125;vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; /**n皇后的意思是行列都只能有一个，且对角线不能有超过两个这里也需要对行列以及对角线进行标记*/ vector&lt;vector&lt;string&gt;&gt; result; if(n==0) return result; //vector&lt;vector&lt;char&gt;&gt; nums(n,vector&lt;char&gt;(n,'.')); //vector&lt;int&gt; row(n,0); // vector&lt;int&gt; col(n,0); vector&lt;int&gt; place(n,-1); dfs(result,place,n,0); return result;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS与回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双指针]]></title>
    <url>%2F2018%2F06%2F03%2F%E5%8F%8C%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[双指针的应用场景比较明显。 1，两数之和||-输入有序数组 2，平方数之和 3，反转字符串中的元音字母 4，验证回文字符串|| 5，合并两个有序数组 6，环形链表 7，单词中的最长子序列 1，两数之和||-输入有序数组给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。说明:返回的下标值（index1 和 index2）不是从零开始的。你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。示例:输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。123456789101112131415161718192021222324vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;/**思路：左右夹(题目说了有且仅有唯一的答案，那就少了一些判断了)*/ int left = 0 , right = numbers.size()-1; vector&lt;int&gt; result(2); while(left&lt;right) &#123; if(numbers[left]+numbers[right] == target) break; if(numbers[left]+numbers[right] &lt; target) &#123; left++; &#125; else &#123; right--; &#125; &#125; //因为说了有唯一的解，这里就不判断了 result[0] = left+1; result[1] = right+1; return result;&#125; 2，平方数之和给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c。示例1:输入: 5输出: True解释: 1 1 + 2 2 = 5示例2:输入: 3输出: False12345678910111213141516bool judgeSquareSum(int c) &#123; /** 也是左右夹 */ int left = 0 ,right = sqrt(c);//这里还是加上sqrt好 while(left&lt;=right) &#123; if(left*left+right*right == c) return true; else if(left*left+right*right &lt; c) left++; else right--; &#125; return false; &#125; 3，反转字符串中的元音字母编写一个函数，以字符串作为输入，反转该字符串中的元音字母。示例 1：给定 s = “hello”, 返回 “holle”.示例 2：给定 s = “leetcode”, 返回 “leotcede”.注意:元音字母不包括 “y”.1234567891011121314151617181920212223242526272829bool check(char c1) &#123; char cc[] =&#123;'a','e','i','o','u','A','E','I','O','U'&#125;; for(auto temp:cc) &#123; if(temp == c1) return true; &#125; return false; &#125; string reverseVowels(string s) &#123; int left = 0 ,right = s.size()-1; while(left&lt;right) &#123; while(left&lt;right&amp;&amp;!check(s[left])) left++; while(left&lt;right&amp;&amp;!check(s[right])) right--; if(left&lt;right) &#123; char temp = s[left]; s[left] = s[right]; s[right] = temp; left++; right--; &#125; &#125; return s; &#125; 4，验证回文字符串||给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。示例 1:输入: “aba”输出: True示例 2:输入: “abca”输出: True解释: 你可以删除c字符。注意:字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。12345678910111213141516171819202122232425bool check(string s,int left, int right) &#123; while(left&lt;right) &#123; if(s[left]!=s[right]) return false; left++; right--; &#125; return true; &#125; bool validPalindrome(string s) &#123; /** 最多删一个字符，，所以可以两边夹 */ int left =0, right =s.length()-1; while(left&lt;right) &#123; if(s[left]!=s[right]) return check(s,left+1,right)||check(s,left,right-1); left++; right--; &#125; return true; &#125; 5，合并两个有序数组给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。说明:初始化 nums1 和 nums2 的元素数量分别为 m 和 n。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。示例:输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出: [1,2,2,3,5,6]来源： https://leetcode-cn.com/problems/merge-sorted-array/description/1234567891011121314151617181920void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; /** 从后面排序移动的会更少 */ int index = m+n-1; m--; n--; while(m&gt;=0&amp;&amp;n&gt;=0) &#123; if(nums1[m]&gt;nums2[n]) nums1[index--] = nums1[m--]; else nums1[index--] = nums2[n--]; &#125; while(n&gt;=0) &#123; nums1[n]=nums2[n]; n--; &#125; &#125; 6，环形链表给定一个链表，判断链表中是否有环。进阶：你能否不使用额外空间解决此题？123456789101112131415bool hasCycle(ListNode *head) &#123; /** 快慢指针 */ if(head == NULL|| head-&gt;next == NULL) return false; ListNode* left =head,*right=head-&gt;next; while(left!=NULL&amp;&amp;right!=NULL&amp;&amp;right-&gt;next!=NULL) &#123; if(left == right) return true; left=left-&gt;next; right=right-&gt;next-&gt;next; &#125; return false; &#125; 7，单词中的最长子序列Input:s = “abpcplea”, d = [“ale”,”apple”,”monkey”,”plea”]Output:“apple”题目描述：删除 s 中的一些字符，使得它构成字符串列表 d 中的一个字符串，找出能构成的最长字符串。如果有多个相同长度的结果，返回按字典序排序的最大字符串。12345678910111213141516171819202122232425262728string findLongestWord(string s, vector&lt;string&gt;&amp; d) &#123; /** 原本想的是d排序，然后在s中查找是否存在该序列 */ auto comp = [](const string&amp; p1, const string&amp; p2)&#123; return p1.length()&gt;p2.length()?true:(p1.length()==p2.length()?p1&lt;p2:false); &#125;; sort(d.begin(), d.end(), comp); for(auto&amp; temp : d) &#123; int indexs=0,indext=0; while(indexs&lt;s.size()&amp;&amp;indext&lt;temp.size()) &#123; if(s[indexs]==temp[indext]) &#123; indexs++; indext++; &#125; else &#123; indexs++; &#125; &#125; if(indext==temp.size()) return temp; &#125; return ""; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法]]></title>
    <url>%2F2018%2F06%2F03%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[贪心算法是保证局部最优，最终的结果是全局最优解 1 分发饼干 2 买卖股票的最佳时机 3 种花问题 4 非递减数列 5 判断子序列 6 用最少数量的箭刺破气球 7 划分字母区间 8 根据身高重建队列 1 分发饼干假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。注意：你可以假设胃口值为正。一个小朋友最多只能拥有一块饼干。示例 1:输入: [1,2,3], [1,1]输出: 1解释:你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。示例 2:输入: [1,2], [1,2,3]输出: 2解释:你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2.来源： https://leetcode-cn.com/problems/assign-cookies/description/123456789101112131415int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123; /**思路：这题将所有排序，然后一个个比较应该就可以 */ sort(g.begin(),g.end());sort(s.begin(), s.end());int indexG = 0,indexS=0;while(indexG &lt; g.size()&amp;&amp;indexS&lt;s.size())&#123; if(g[indexG]&lt;=s[indexS]) indexG++; indexS++; &#125;return indexG;&#125; 2 买卖股票的最佳时机给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。示例 1:输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。示例 2:输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。示例 3:输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。123456789101112131415int maxProfit(vector&lt;int&gt;&amp; prices) &#123; /** 思路：这题保证局部最优最后的结果应该是最优，因为不能连续买或者卖，每次只要保证前后就可以了 */ int result =0,index=1; while(index&lt;prices.size()) &#123; if(prices[index]&gt;prices[index-1]) &#123; result+=prices[index]-prices[index-1]; &#125; index++; &#125; return result;&#125; 3 种花问题假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。示例 1:输入: flowerbed = [1,0,0,0,1], n = 1输出: True示例 2:输入: flowerbed = [1,0,0,0,1], n = 2输出: False注意:数组内已种好的花不会违反种植规则。输入的数组长度范围为 [1, 20000]。n 是非负整数，且不会超过输入数组的大小。1234567891011121314151617181920212223bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) &#123; /** 思路：种花的话，保证前后和本身为0的就可以种，最后看全局剩下的结果 */ int index =0; while(index&lt;flowerbed.size()) &#123; if(flowerbed[index]==1) &#123; index++; continue; &#125; int pre = index==0?0:flowerbed[index-1]; int next = index == flowerbed.size()-1?0:flowerbed[index+1]; if(!pre&amp;&amp;!next) &#123; n--; flowerbed[index]=1; &#125; index++; &#125;return n&lt;=0;&#125; 4 非递减数列给定一个长度为 n 的整数数组，你的任务是判断在最多改变 1 个元素的情况下，该数组能否变成一个非递减数列。我们是这样定义一个非递减数列的： 对于数组中所有的 i (1 &lt;= i &lt; n)，满足 array[i] &lt;= array[i + 1]。示例 1:输入: [4,2,3]输出: True解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。示例 2:输入: [4,2,1]输出: False解释: 你不能在只改变一个元素的情况下将其变为非递减数列。说明: n 的范围为 [1, 10,000]。123456789101112131415161718192021 bool checkPossibility(vector&lt;int&gt;&amp; nums) &#123; /** 思路：原来的思想是只比较前后两个，后面小就加一，但是发现若后面index+1比前面index-1还小的情况，因此重新考虑这里将数组进行替换操作，[index]&lt;[index-1]的时候，一般是考虑将[index-1]=[index],不然反过来的话后面的值会变大，这样可能会影响后面的顺序；还有特殊情况[index]&lt;[index-1] [index]&lt;[index-2],这样的话只有[index]=[index-1]了 */ int index =1,count=0; while(index&lt;nums.size()) &#123; if(nums[index]&lt;nums[index-1]) &#123; if(index-2&gt;=0&amp;&amp;nums[index]&lt;nums[index-2]) nums[index] = nums[index-1];//后一个值变大 else nums[index-1]=nums[index];//前一个值变小 count++; &#125; index++; &#125;return count&lt;=1; &#125; 5 判断子序列给定字符串 s 和 t ，判断 s 是否为 t 的子序列。你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。示例 1:s = “abc”, t = “ahbgdc”返回 true.示例 2:s = “axc”, t = “ahbgdc”返回 false.后续挑战 :如果有大量输入的 S，称作S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？123456789101112131415bool isSubsequence(string s, string t) &#123; /** 这里是判断子序列，区分于子串 判断的时候以s作为基准就好了 */ if(s.size()==0) return true; int i = 0,j=0; while(i&lt;s.size()&amp;&amp;j&lt;t.size()) &#123; if(s[i]==t[j]) i++; j++; &#125; return i&gt;=s.size();&#125; 6 用最少数量的箭刺破气球在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以y坐标并不重要，因此只要知道开始和结束的x坐标就足够了。开始坐标总是小于结束坐标。平面内最多存在104个气球。一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。Example:输入:[[10,16], [2,8], [1,6], [7,12]]输出:2解释:对于该样例，我们可以在x = 6（射爆[2,8],[1,6]两个气球）和 x = 11（射爆另外两个气球）。来源： https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/description/12345678910111213141516171819202122232425static bool comp(pair&lt;int,int&gt; p1,pair&lt;int,int&gt; p2) &#123; return p1.second&lt;=p2.second; //这里只用终点排序就行，不用关注起点 &#125;int findMinArrowShots(vector&lt;pair&lt;int, int&gt;&gt;&amp; points) &#123; /** 这种关于活动选择的问题，其变形还有关于参加活动的起始与结束时间 其实可以按照终点对气球进行排序即可，终点重合的算一个 */ if(points.size()==0) return 0; int result =1; sort(points.begin(),points.end(),comp); pair&lt;int,int&gt; temp = points[0]; int index =1; while(index&lt;points.size()) &#123; if(points[index].first &gt; temp.second) &#123; result++; temp = points[index]; &#125; index++; &#125; return result; &#125; 7 划分字母区间字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。示例 1:输入: S = “ababcbacadefegdehijhklij”输出: [9,7,8]解释:划分结果为 “ababcbaca”, “defegde”, “hijhklij”。每个字母最多出现在一个片段中。像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。注意:S的长度在[1, 500]之间。S只包含小写字母’a’到’z’。12345678910111213141516171819202122232425262728vector&lt;int&gt; partitionLabels(string S) &#123;/**思路：贪心法保证局部最小就行，这样就能分的最多要保证分的最小，则每次得关注片段里面的字符在右边没有出现过开始以最左边的开始，肯定是第一个片段*/ vector&lt;int&gt; result,finalIndex(26,0);int left =0;for(int i=0; i&lt;S.size(); i++)&#123; finalIndex[S[i]-'a'] = i;//记录最后一个的索引&#125;while(left&lt;S.size())&#123; int right = finalIndex[S[left]-'a']; for(int k = left;k&lt;=right;k++) &#123; if(finalIndex[S[k]-'a']&gt;right) &#123; right = finalIndex[S[k]-'a']; continue; &#125; &#125; result.push_back(right-left+1); left=right+1;&#125;return result;&#125; 8 根据身高重建队列假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。注意：总人数少于1100人。示例输入:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]输出:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]来源： https://leetcode-cn.com/problems/queue-reconstruction-by-height/description/1234567891011121314151617vector&lt;pair&lt;int, int&gt;&gt; reconstructQueue(vector&lt;pair&lt;int, int&gt;&gt;&amp; people) &#123;/**队列的插入规则先按照高的插入，这样低的插入后不会改变已经插入的k值；若有相同高度，则按照k值递增插入*/ auto comp = [](const pair&lt;int, int&gt;&amp; p1, const pair&lt;int, int&gt;&amp; p2)&#123; return (p1.first&gt;p2.first)||(p1.first==p2.first&amp;&amp;p1.second&lt;p2.second); &#125;;sort(people.begin(), people.end(), comp);vector&lt;pair&lt;int,int&gt;&gt; result;for(pair&lt;int,int&gt; p:people)&#123; //注意Insert方法，会移动里面已有的元素 result.insert(result.begin()+p.second, p);//按照first排完序后，second就是相对的要插入的索引&#125; return result;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于二分查找算法]]></title>
    <url>%2F2018%2F06%2F03%2F%E5%85%B3%E4%BA%8E%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[二分查找是常见算法。 1，x 的平方根 2，排列硬币 3，寻找比目标字母大的最小字母 4，有序数组的 Single Element 5，第一个错误的版本 6，旋转数组的最小数字 7，查找区间 1，x 的平方根实现 int sqrt(int x) 函数。计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。示例 1:输入: 4输出: 2示例 2:输入: 8输出: 2说明: 8 的平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去1234567891011121314151617181920int mySqrt(int x) &#123;/** 思路：二分法，比较mid 与x/mid的值，当mid&lt; x/mid的时候，保留右边。 这里不写成mid*mid与x进行比较的原因是防止溢出 */ if(x&lt;=1) return x; int left = 1,right =x/2; while(left&lt;=right) &#123; int mid = left+(right -left)/2; int temp = x/mid; if (mid == temp) return mid; if( mid &gt; temp) right = mid -1; else left = mid +1; &#125; return right;&#125; 2，排列硬币你总共有 n 枚硬币，你需要将它们摆成一个阶梯形状，第 k 行就必须正好有 k 枚硬币。给定一个数字 n，找出可形成完整阶梯行的总行数。n 是一个非负整数，并且在32位有符号整型的范围内。示例 1:n = 5硬币可排列成以下几行:¤¤ ¤¤ ¤因为第三行不完整，所以返回2.示例 2:n = 8硬币可排列成以下几行:¤¤ ¤¤ ¤ ¤¤ ¤因为第四行不完整，所以返回3.来源： https://leetcode-cn.com/problems/arranging-coins/description/12345678910111213141516171819int arrangeCoins(int n) &#123; /** 二分查找：和(1+x)x/2 与n进行比较 */ if(n&lt;=1) return n; int left = 1, right = n; ///这里的int在Leetcode中过不了大数据用例，全改为long while(left &lt;= right) &#123; int mid = left + (right - left)/2; int sum=(mid+1)*mid/2; if(sum == x) return mid; if(sum &gt; x) right = mid -1; else left = mid+1; &#125;return right;&#125; 当然还有不用二分法，简单的循环12345678910111213141516 int arrangeCoins(int n) &#123;/** int level = 1; while(n&gt;0) &#123; n-=level++; &#125; return n==0?level-1:level-2; &#125;*/ int level=1; while(n&gt;=level) &#123; n-=level++; &#125; return level-1; &#125; 3，寻找比目标字母大的最小字母给定一个只包含小写字母的有序数组letters 和一个目标字母 target，寻找有序数组里面比目标字母大的最小字母。数组里字母的顺序是循环的。举个例子，如果目标字母target = ‘z’ 并且有序数组为 letters = [‘a’, ‘b’]，则答案返回 ‘a’。示例:输入:letters = [“c”, “f”, “j”]target = “a”输出: “c”输入:letters = [“c”, “f”, “j”]target = “c”输出: “f”输入:letters = [“c”, “f”, “j”]target = “d”输出: “f”输入:letters = [“c”, “f”, “j”]target = “g”输出: “j”输入:letters = [“c”, “f”, “j”]target = “j”输出: “c”输入:letters = [“c”, “f”, “j”]target = “k”输出: “c”注:letters长度范围在[2, 10000]区间内。letters 仅由小写字母组成，最少包含两个不同的字母。目标字母target 是一个小写字母。1234567891011121314151617char nextGreatestLetter(vector&lt;char&gt;&amp; letters, char target)&#123; /** 大于target的数有很多，这里只需要找到第一个大于的就行 等效于找到最后一个小于等于target的数 */ int left = 0, right = letters.size() - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (letters[mid] &lt;= target) left = mid + 1; else right = mid - 1; &#125; //因为已经说了最少包含两个不同字母，且是循环比较大小，所以最右边的left不存在就在0位 return left &gt;= letters.size() ? letters[0] : letters[left];&#125; 4，有序数组的 Single Element给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。示例 1:输入: [1,1,2,3,3,4,4,8,8]输出: 2示例 2:输入: [3,3,7,7,10,11,11]输出: 10注意: 您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。1234567891011121314151617181920int singleNonDuplicate(vector&lt;int&gt;&amp; nums)&#123; /** 思路：这种只出现一次的，最开始想到的是用位运算，但是位运算的事件复杂度是n, 题目说了是有序数组，那么就尝试二分查找，事件复杂度为logN 因为是有序，所以可等效于查找 */ int left = 0, right = nums.size() - 1; while (left &lt; right) // 这里相等的时候就是所求的值，与其他不同 &#123; int mid = left + (right - left) / 2; if (mid % 2) --mid; //保证一直是偶数位 if (nums[mid] == nums[mid + 1]) left = mid + 2; else right = mid; &#125; return nums[left]; //left==right&#125; 5，第一个错误的版本你是产品经理，目前正在领导一个团队开发一个新产品。不幸的是，您的产品的最新版本没有通过质量检查。由于每个版本都是基于之前的版本开发的，所以错误版本之后的所有版本都是不好的。假设你有 n 个版本 [1, 2, …, n]，你想找出第一个错误的版本，导致下面所有的错误。你可以通过 bool isBadVersion(version) 的接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。您应该尽量减少对 API 的调用次数。来源： https://leetcode-cn.com/problems/first-bad-version/description/12345678910111213141516int firstBadVersion(int n) &#123; /** 思路：最简单的二分查找判断 */ int left = 1, right = n; while (left &lt; right) //这里相等的时候也是最后的结果 &#123; int mid = left + (right - left) / 2; if (isBadVersion(mid)) right = mid; //与上面找有序数组的一样，注意有错的时候那位 else left = mid + 1; &#125; return left; //right==left&#125; 6，旋转数组的最小数字假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2]）。找到其中最小的元素。你可以假设数组中不存在重复元素。示例:输入: [3,4,5,1,2],输出: 112345678910111213141516171819int findMin(vector&lt;int&gt;&amp; nums) &#123; /** 思路：这题与找循环字母的那题有些类似 */ int left = 0, right = nums.size() - 1; while (left &lt; right) //left==right同样也是结束条件 &#123; if (nums[right] &gt;= nums[left]) return nums[left]; //这句话不能少，不然判断和左边判断的时候会有问题 int mid = left + (right - left) / 2; if (nums[mid] &lt; nums[left]) right = mid; else left = mid + 1; &#125;//最后的结束条件 return nums[right]; //left ==right&#125; 7，查找区间给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。你的算法时间复杂度必须是 O(log n) 级别。如果数组中不存在目标值，返回 [-1, -1]。Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4]Input: nums = [5,7,7,8,8,10], target = 6Output: [-1,-1]1234567891011121314151617181920212223242526272829vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target)&#123; vector&lt;int&gt; result(2, -1); if (nums.size() == 0) return result; int left = 0, right = nums.size() - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &gt;= target) right = mid - 1; else left = mid + 1; &#125; if (left &gt;= nums.size() || nums[left] != target) //这是与之前不同的地方，因为可能不存在，所以要判断边界与值 return result; result[0] = left; left = 0, right = nums.size() - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &lt;= target) left = mid + 1; else right = mid - 1; &#125; if (right &lt; 0 || nums[right] != target) return result; result[1] = right; return result;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于链表LinkedList]]></title>
    <url>%2F2018%2F04%2F25%2F%E5%85%B3%E4%BA%8E%E9%93%BE%E8%A1%A8LinkedList%2F</url>
    <content type="text"><![CDATA[链表的主要操作包括遍历与头插的寻找等。 1，合并两个有序链表 2，反转单链表 3，删除排序链表中的重复元素 4，删除链表中的节点 5，删除链表中的元素 6，回文链表 7，环形链表 8，相交链表 1，合并两个有序链表将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。示例：输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;412345678/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */ 1234567891011121314151617181920212223242526272829303132333435363738394041ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; /** 法一：递归 法二：循环 */ /** if(l1 == NULL) return l2; if(l2 ==NULL) return l1; if(l1-&gt;val &lt; l2-&gt;val) &#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else &#123; l2-&gt;next = mergeTwoLists(l2-&gt;next,l1); return l2; &#125; **/ if(l1 == NULL) return l2; if(l2 ==NULL) return l1; ListNode* resultList = new ListNode(-1); ListNode* temp =resultList; while(l1&amp;&amp;l2) &#123; if(l1-&gt;val &lt; l2-&gt;val) &#123; temp-&gt;next = l1; l1=l1-&gt;next; &#125; else &#123; temp-&gt;next = l2; l2 =l2-&gt;next; &#125; temp=temp-&gt;next; &#125; temp-&gt;next = l1?l1:l2; return resultList-&gt;next; &#125; 2，反转单链表进阶:链表可以迭代或递归地反转。你能否两个都实现一遍？12345678910111213ListNode* reverseList(ListNode* head) &#123; if(head == NULL || head-&gt;next == NULL) return head; ListNode* resultList = new ListNode(-1); ListNode* temp = NULL; while(head!=NULL) &#123; temp=head-&gt;next; head-&gt;next = resultList-&gt;next; resultList-&gt;next = head; head = temp; &#125; return resultList-&gt;next; &#125; 尝试用递归的方法做1234567//如果链表为空或者链表中只有一个元素 if(head ==NULL ||head-&gt;next == NULL) return head; ListNode* newHead = reverseList(head-&gt;next); head-&gt;next-&gt;next=head; head-&gt;next = NULL; return newHead; 3，删除排序链表中的重复元素给定一个排序链表，删除所有重复的元素使得每个元素只留下一个。案例：给定 1-&gt;1-&gt;2，返回 1-&gt;2给定 1-&gt;1-&gt;2-&gt;3-&gt;3，返回 1-&gt;2-&gt;3123456789101112ListNode* deleteDuplicates(ListNode* head) &#123; if(head == NULL || head-&gt;next ==NULL) return head; ListNode* p =head, *q =head; while(q !=NULL) &#123; while(q!=NULL&amp;&amp;q-&gt;val==p-&gt;val) q=q-&gt;next; p-&gt;next=q; p=p-&gt;next; &#125; return head; &#125; 4，删除链表中的节点请编写一个函数，使其可以删除某个链表中给定的（非末尾的）节点，您将只被给予要求被删除的节点。比如：假设该链表为 1 -&gt; 2 -&gt; 3 -&gt; 4 ，给定您的为该链表中值为 3 的第三个节点，那么在调用了您的函数之后，该链表则应变成 1 -&gt; 2 -&gt; 4 。1234567void deleteNode(ListNode* node) &#123; /** 题目已经说了是指定的非尾节点了 */ node-&gt;val = node-&gt;next-&gt;val; node-&gt;next = node-&gt;next-&gt;next; &#125; 5，删除链表中的元素删除链表中等于给定值 val 的所有元素。示例给定: 1 –&gt; 2 –&gt; 6 –&gt; 3 –&gt; 4 –&gt; 5 –&gt; 6, val = 6返回: 1 –&gt; 2 –&gt; 3 –&gt; 4 –&gt; 512345678910111213141516171819202122 ListNode* removeElements(ListNode* head, int val) &#123;/**主要是判断重复值是否到了最后*/ if(head == NULL) return head; ListNode* temp = new ListNode(-1); ListNode* result = temp; while(head != NULL) &#123; while(head!=NULL &amp;&amp; head-&gt;val == val) &#123; head=head-&gt;next; &#125; temp-&gt;next = head; temp =temp-&gt;next; if(head == NULL) return result-&gt;next; else head = head-&gt;next; &#125; return result-&gt;next; &#125; 6，回文链表请检查一个链表是否为回文链表。进阶：你能在 O(n) 的时间和 O(1) 的额外空间中做到吗？12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152ListNode* reversrList(ListNode* head)&#123;if(head == NULL ||head-&gt;next == NULL) return head;ListNode* result = new ListNode(-1);ListNode* temp =NULL;while(head != NULL)&#123; temp=head-&gt;next; head-&gt;next=result-&gt;next; result-&gt;next =head; head = temp;&#125;return result-&gt;next;&#125;ListNode* getMidNode(ListNode* head)&#123;//查找中间节点，奇数的话返回中间的前面一个/** 用两个指针快速查找中间点*/if(head == NULL || head-&gt;next == NULL) return head;ListNode* fast=head, *slow=head;while(fast!=NULL&amp;&amp;fast-&gt;next!=NULL&amp;&amp;fast-&gt;next-&gt;next!=NULL)&#123; fast = fast-&gt;next-&gt;next; slow=slow-&gt;next;&#125;return slow;&#125;/**检查链表是否是回文链表在O(n的时间和O(1)空间做出*/bool isPalindrome(ListNode* head) &#123; /** 思路：O(n)的时间，O(1)空间考虑是找链表中间(注意奇偶)，后半部翻转，然后和前面的比较 */ if(head == NULL ||head-&gt;next ==NULL) return true; //奇数的话从中间的一个，偶数的话是对称的前一个 ListNode* midNode = getMidNode(head); midNode-&gt;next = reversrList(midNode-&gt;next); //逐个比较 while(midNode-&gt;next!=NULL) &#123; if(head-&gt;val != midNode-&gt;next-&gt;val) return false; head = head-&gt;next; midNode = midNode-&gt;next; &#125; return true; &#125; 7，环形链表给定一个链表，判断链表中否有环。补充：你是否可以不用额外空间解决此题？123456789101112131415bool hasCycle(ListNode *head) &#123; /** 思路：有环的话单链表一般是在尾部有环，通常考虑的是快慢指针跑，看看会不会相遇 */ if(head == NULL ||head-&gt;next ==NULL) return false; ListNode * slow = head, *fast = head-&gt;next-&gt;next;//开始得先跑两步 while(fast!= NULL&amp;&amp;fast-&gt;next!=NULL&amp;&amp;slow!=NULL) &#123; if(fast == slow) return true; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; return false; &#125; 8，相交链表编写一个程序，找到两个单链表相交的起始节点。例如，下面的两个链表：A: a1 → a2 ↘ c1 → c2 → c3 ↗B: b1 → b2 → b3在节点 c1 开始相交。注意：如果两个链表没有交点，返回 null.在返回结果后，两个链表仍须保持原有的结构。可假定整个链表结构中没有循环。程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; /** 思路：相交后的节点都是相同的，在有限的时间和空间下， 两个指针，先统计两个链表的长度，长度差就是指针先跑的地方 *//** if(headA == NULL || headB == NULL) return NULL; int countA = 0, countB = 0; ListNode * tempA=headA,*tempB=headB; while(tempA-&gt;next != NULL) &#123; ++countA; tempA = tempA-&gt;next; &#125; while(tempB-&gt;next != NULL) &#123; ++countB; tempB = tempB-&gt;next; &#125; if(tempA != tempB) return NULL; tempA=headA; tempB=headB; if(countA-countB&gt;0) &#123; countA = countA-countB; while(countA&gt;0) &#123; tempA = tempA-&gt;next; --countA; &#125; &#125; else if(countA-countB&lt;0) &#123; countB = countB-countA; while(countB&gt;0) &#123; tempB = tempB-&gt;next; --countB; &#125; &#125; while(tempA!=NULL) &#123; if( tempA == tempB) return tempA; tempA=tempA-&gt;next; tempB=tempB-&gt;next; &#125; return NULL;**//**还有一种更简单的做法*/ if(headA == NULL || headB == NULL) return NULL; ListNode* l1 = headA, *l2 = headB; while(l1 != l2)&#123; l1 = (l1 == NULL) ? headB : l1-&gt;next; l2 = (l2 == NULL) ? headA : l2-&gt;next; &#125; return l1 &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新建一个hexo模版的文件]]></title>
    <url>%2F2018%2F04%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[这里只是简单的记录下一些操作，包括一些前人踩过的坑。 新建一个提交 Generate static files Run server Deploy to remote sites 遇到的问题 hexo与github page结合可以很方便的搭建出个人的静态网页博客。 新建一个提交1$ hexo new "My New Post" 在根目录而非我们自己的themes的根目录下执行上述命令，hexo会自动在根目录的_posts文件夹下面生成相关的md文件；然后打开该文件就可写我们自己的博客，具体的语法规则详见: Writing Generate static files1$ hexo generate 该命令生成静态页面至public目录详见: Generating Run server1$ hexo server hexo server 可简化为命令 hexo s，开启预览访问端口，默认是4000端口，打开浏览器访问 http://localhost:4000 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考这篇文章：http://blog.liuxianan.com/windows-port-bind.html更多信息详见: Server Deploy to remote sites1$ hexo deploy 发布过程，发布中可能需要先装一个插件1npm install hexo-deployer-git --save 详见: Deployment 最后注意中文的编码问题，保存的时候记得保存编码为”UTF-8” 遇到的问题1 一段时间没登录后，使用hexo遇到下面的问题(20181125)1/c/Users/cai/AppData/Roaming/npm/hexo: line 12: node: command not found 自己记得没有删除过hexo，网上搜了下参考，发现好像自己的node.js在开机清理垃圾的时候被删除了，于是安装了一下node.js，hexo就可以正常使用了。 具体的手把手教程可参考：https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html https://segmentfault.com/a/1190000004359502 https://blog.csdn.net/u012195214/article/details/79204088]]></content>
  </entry>
</search>
