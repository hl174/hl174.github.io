<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[百度开源rpc框架sofa-pbrpc与b-rpc]]></title>
    <url>%2F2018%2F11%2F25%2F%E7%99%BE%E5%BA%A6%E5%BC%80%E6%BA%90rpc%E6%A1%86%E6%9E%B6sofa-pdbrpc%E4%B8%8Eb-rpc%2F</url>
    <content type="text"><![CDATA[进程间常见的通信方式有消息队列、RPC、管道通信等，而RPC是目前许多公司中应用较为广泛的一种。]]></content>
      <categories>
        <category>Linux 网络编程</category>
      </categories>
      <tags>
        <tag>网络编程之RPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO多路复用之select、poll、epoll详解]]></title>
    <url>%2F2018%2F11%2F25%2FIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8Bselect%E3%80%81poll%E3%80%81epoll%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[关于IO多路复用，必然涉及常见的模式，这里最经典的模型当属Scalable IO in Java 1 1]]></content>
      <categories>
        <category>Linux 网络编程</category>
      </categories>
      <tags>
        <tag>网络编程之IO多路复用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络编程中的Proactor和Reactor模式]]></title>
    <url>%2F2018%2F11%2F25%2F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84Proactor%E5%92%8CReactor%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[网络编程中比较常见的设计模式是Proactor和Reactor模式 1 Proactor模式 2 Reactor模式 1 Proactor模式2 Reactor模式]]></content>
      <categories>
        <category>Linux 网络编程</category>
      </categories>
      <tags>
        <tag>网络编程之设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于tcp的简单socket编程]]></title>
    <url>%2F2018%2F06%2F10%2F%E5%9F%BA%E4%BA%8Etcp%E7%9A%84%E7%AE%80%E5%8D%95socket%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[有段时间没有写网络这块的，最近学习下。 1 服务器代码 2 客户端的代码 3 关于socket中的send recv函数 3.1 send函数 3.2 recv函数 这篇帖子上介绍的linux下的基于tcp的socket编程不错，https://www.cnblogs.com/MyLove-Summer/p/5215287.html。这里贴下一个主要的图，一个基于tcp的网络编程的图。这里来一个简单的例子，一个客户端ClientSock，一个服务端ServerSock，服务器这边监听的端口号是20000，让客户端连上服务器后发送数据，服务器收到后打印出来。 1 服务器代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt;#include &lt;sys/socket.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;netinet/in.h&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;cstring&gt;#include &lt;arpa/inet.h&gt;#define SERVER_PORT 20000#define LENGTH_OF_LISTEN_QUEUE 10#define BUFFER_SIZE 255int main(int argc, char const *argv[])&#123;int servfd,clifd;struct sockaddr_in servaddr,cliaddr;if((servfd = socket(AF_INET,SOCK_STREAM, 0)) &lt; 0)&#123;printf("创建服务端socket失败, servfd[%d]", servfd);exit(1);&#125;bzero(&amp;servaddr , sizeof(servaddr));servaddr.sin_family = AF_INET;servaddr.sin_port = htons(SERVER_PORT);servaddr.sin_addr.s_addr =htons(INADDR_ANY);//INADDR_ANY就是指定地址为0.0.0.0if(bind(servfd, (struct sockaddr *)&amp; servaddr, sizeof(servaddr)) &lt; 0)&#123;printf("绑定到端口%d失败 \n", SERVER_PORT);exit(1);&#125;if(listen(servfd, LENGTH_OF_LISTEN_QUEUE)&lt;0)&#123;printf("回调listen失败 \n");exit(1);&#125;while(1)&#123;//服务端一直不退出，除非进程呗杀死char buf[BUFFER_SIZE];long timestamp;socklen_t length = sizeof(cliaddr);//accept是三次握手的服务端clifd = accept(servfd, ( struct sockaddr *) &amp;cliaddr, &amp;length);if(clifd &lt; 0)&#123;printf("回调accept的时候发生错误");break; // 跳出循环&#125;printf("来自客户端的ip:%s,端口号:%d,clifd[%d] \n", inet_ntoa(cliaddr.sin_addr), ntohs(cliaddr.sin_port), clifd);timestamp = time(NULL);int lengthrec = 0;lengthrec = recv(clifd, buf, BUFFER_SIZE, 0);//接受的是clifdif(lengthrec &lt; 0)&#123;printf("接受客户端的消息失败, lengthrec[%d]\n",lengthrec);exit(1);&#125;printf("来自客户端的数据为[%s] \n",buf);//server收到消息后再发一次消息bzero(buf,sizeof(buf));strcpy(buf,"server收到了client的消息，这是给你的ack回复");send(clifd,buf,BUFFER_SIZE,0); //还是刚才的clifdclose(clifd);//关闭客户端的文件描述符&#125;close(servfd);getchar();return 0;&#125; 本地测试的时候，为了不让终端一闪而过，最后加了个getchar()函数，让其停住。 2 客户端的代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;sys/socket.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;netinet/in.h&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;cstring&gt;#include &lt;arpa/inet.h&gt;#define SERVER_PORT 20000#define CLIENT_PORT ((20001+rand())%65536)#define BUFFER_SIZE 255void usage(char *name)&#123;printf("usage:%s ",name);&#125;int main(int argc, char *argv[])&#123;int clifd,length =0;struct sockaddr_in servaddr,cliaddr;socklen_t socklen = sizeof(servaddr);char buf[BUFFER_SIZE];if(argc &lt; 2)&#123;usage(argv[0]);exit(1);&#125;if((clifd =socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)&#123;printf("创建客户端的fd失败\n");exit(1);&#125;srand(time(NULL));bzero(&amp;cliaddr, sizeof(cliaddr));cliaddr.sin_family = AF_INET;cliaddr.sin_port = htons(CLIENT_PORT);cliaddr.sin_addr.s_addr = htons(INADDR_ANY);bzero(&amp;servaddr, sizeof(servaddr));servaddr.sin_family = AF_INET;inet_aton(argv[1], &amp;servaddr.sin_addr);servaddr.sin_port = htons(SERVER_PORT);if(bind(clifd , (struct sockaddr*) &amp;cliaddr, sizeof(cliaddr)) &lt; 0)&#123;printf("绑定到端口%d失败\n", CLIENT_PORT);exit(1);&#125;if( connect(clifd, (struct sockaddr*)&amp;servaddr, socklen) &lt; 0)&#123;printf("不能够连接到%s!\n", argv[1]);exit(1);&#125;strcpy(buf,"是服务器么，我是客户端");send(clifd, buf, BUFFER_SIZE, 0); //clifd绑定的connect,发的话就是这个socketprintf("客户端发送完了,clifd[%d]\n", clifd);bzero(buf,sizeof(buf));recv(clifd,buf,BUFFER_SIZE,0); //接受消息也是同一个clifdprintf("client发完后又收到了server的消息，消息[%s]",buf);close(clifd);getchar();return 0;&#125; linux下还没有安啥ide，就用两个控制台来看可让服务器不关，client端多次运行这里服务器收到了是每次客户端不同的端口号。这样简单实现了一次通信，至于复杂的多次通信包括select poll epoll等可以继续包装。 3 关于socket中的send recv函数在建立socket后收发数据的时候，用到了send() recv()函数，它们的第一个参数都是fd，这里开始看了一些网上各种抄的版本后，发现收不到数据，自己然后看了下源码和man手册1234567891011121314151617181920212223242526272829303132/* Send N bytes of BUF to socket FD. Returns the number sent or -1. This function is a cancellation point and therefore not marked with __THROW. */extern ssize_t send (int __fd, const void *__buf, size_t __n, int __flags);/* Read N bytes into BUF from socket FD. Returns the number read or -1 for errors. This function is a cancellation point and therefore not marked with __THROW. */extern ssize_t recv (int __fd, void *__buf, size_t __n, int __flags);/* Send N bytes of BUF on socket FD to peer at address ADDR (which is ADDR_LEN bytes long). Returns the number sent, or -1 for errors. This function is a cancellation point and therefore not marked with __THROW. */extern ssize_t sendto (int __fd, const void *__buf, size_t __n, int __flags, __CONST_SOCKADDR_ARG __addr, socklen_t __addr_len);/* Read N bytes into BUF through socket FD. If ADDR is not NULL, fill in *ADDR_LEN bytes of it with tha address of the sender, and store the actual size of the address in *ADDR_LEN. Returns the number of bytes read or -1 for errors. This function is a cancellation point and therefore not marked with __THROW. */extern ssize_t recvfrom (int __fd, void *__restrict __buf, size_t __n, int __flags, __SOCKADDR_ARG __addr, socklen_t *__restrict __addr_len); 3.1 send函数1234send(sockfd, buf, len, flags); is equivalent to sendto(sockfd, buf, len, flags, NULL, 0);The argument sockfd is the file descriptor of the sending socket send函数和sendto函数一样，sockfd是发送端的socket描述符。我们这里的例子只是client发数据server，所以是clifd.源码中send是发送n个byte的buf到socket，这个socket就是发送端发送数据前建立的socket。 3.2 recv函数网上的抄的都说第一个参数是指定接受端的套接字描述符。源码解析从socket FD中读n个byte的buf，注意，这里的FD是三次握手建立连接的socket，也就是accept函数返回的socket，我们这里定义的是clifd。针对发送端接收端，其实简单区分不太正确，发送也可接受，主要是看当前的数据socket是哪一条。| 理解清楚send和recv的socket是哪一个就知道fd了 ps&gt;本地测试的时候有时候会发现端口号被占用，例如服务端的端口号20000被占用，查看端口号是否被占用netstat -anp|grep 20000lsof - i:20000杀进程kill -9 pid号ps:关于博客插入图片的参考https://blog.csdn.net/sugar_rainbow/article/details/57415705]]></content>
      <categories>
        <category>Linux 网络编程</category>
      </categories>
      <tags>
        <tag>TCP SOCKET编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS与回溯]]></title>
    <url>%2F2018%2F06%2F03%2FDFS%E4%B8%8E%E5%9B%9E%E6%BA%AF%2F</url>
    <content type="text"><![CDATA[回溯其实属于DFS的一种特殊场景。 1，岛屿的最大面积 2，岛屿数目 3，朋友圈 4，填充封闭区域 5，太平洋和大西洋的水 6，电话号码的字母组合 7，单词搜索 8，二叉树的所有路径 9，全排列 10，全排列|| 11，组合 12，组合总和 13，组合总和|| 14，组合总和III 15，子集 16，子集II 17，分割回文串 18，解数独 19，n皇后 1，岛屿的最大面积给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)示例 1:[[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]]对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。示例 2:[[0,0,0,0,0,0,0,0]]对于上面这个给定的矩阵, 返回 0。注意: 给定的矩阵grid 的长度和宽度都不超过 50来源： https://leetcode-cn.com/problems/max-area-of-island/description/123456789101112131415161718192021int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int i, int j)&#123; if(i&lt;0||i&gt;=grid.size()||j&lt;0||j&gt;=grid[0].size()) return 0; if(!grid[i][j]) return 0; grid[i][j] = 0; return 1+dfs(grid,i,j+1)+dfs(grid,i,j-1)+dfs(grid,i-1,j)+dfs(grid,i+1,j);&#125;int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; /** 深度遍历dfs */ if(grid.size()==0) return 0; int result =0; for(int i =0;i&lt;grid.size();i++) for(int j=0;j&lt;grid[0].size();j++) if(grid[i][j]) result=max(result,dfs(grid,i,j)); return result;&#125; 2，岛屿数目这题与上一题不同，这个是求岛屿的个数，而不是最大的岛屿面积11110110101100000000Answer: 1123456789101112131415161718192021222324252627void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int i, int j)&#123; if(i&lt;0||i&gt;=grid.size()||j&lt;0||j&gt;=grid[0].size()) return ; if(grid[i][j]=='0') return ; grid[i][j] = '0'; dfs(grid,i,j+1); dfs(grid,i,j-1); dfs(grid,i+1,j); dfs(grid,i-1,j);&#125;int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;/**与求最大的岛屿面积不同，不用做max比较，这个是直接计算岛屿数目*/ if(grid.empty()) return 0; int result =0; for(int i =0;i&lt;grid.size();i++) for(int j=0;j&lt;grid[0].size();j++) if(grid[i][j]=='1') &#123; dfs(grid, i , j); ++result; &#125; return result;&#125; 3，朋友圈班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。示例 1:输入:[[1,1,0], [1,1,0], [0,0,1]]输出: 2说明：已知学生0和学生1互为朋友，他们在一个朋友圈。第2个学生自己在一个朋友圈。所以返回2。示例 2:输入:[[1,1,0], [1,1,1], [0,1,1]]输出: 1说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。注意：N 在[1,200]的范围内。对于所有学生，有M[i][i] = 1。如果有M[i][j] = 1，则有M[j][i] = 1。来源： https://leetcode-cn.com/problems/friend-circles/description/123456789101112131415161718192021222324252627282930void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; M, int k, vector&lt;int&gt;&amp; flag)&#123; if(k&lt;0||k&gt;=M.size()) return; if(flag[k]) return; flag[k]=1; for(int i=0;i&lt;M.size();i++) if(!flag[i]&amp;&amp;M[k][i]) &#123; dfs(M,i,flag);//这里其实不需要上下左右，把当前的处理好就行 &#125;&#125;int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123; /** 这种互为关系的情况，应该是降为一维的; 与求岛屿数目类似 同时增加相应的标记位 */ if(M.empty()) return 0; int result =0; vector&lt;int&gt; flag(M.size(), 0); for(int i= 0;i&lt;M.size();i++) if(!flag[i]) &#123; dfs(M,i,flag); result++; &#125; return result;&#125; 4，填充封闭区域给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。示例:X X X XX O O XX X O XX O X X运行你的函数后，矩阵变为：X X X XX X X XX X X XX O X X解释:被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。来源： https://leetcode-cn.com/problems/surrounded-regions/description/12345678910111213141516171819202122232425262728293031323334void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board,int i,int j) &#123; if(i&lt;0||i&gt;=board.size()||j&lt;0||j&gt;=board[0].size()||board[i][j]!='O') return; board[i][j] ='H'; dfs(board,i+1,j); dfs(board,i-1,j); dfs(board,i,j+1); dfs(board,i,j-1); &#125; void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; /** 找到与边缘相联通的区域，作为标记，剩下的非与边缘相连的O最后转为X */ if(board.empty()) return; for(int i=0;i&lt;board.size();i++) &#123; dfs(board,i,0); dfs(board,i,board[0].size()-1); &#125; for(int j=0;j&lt;board[0].size();j++) &#123; dfs(board,0,j); dfs(board,board.size()-1, j); &#125; for(int i=0;i&lt;board.size();i++) for(int j=0;j&lt;board[0].size();j++) &#123; if(board[i][j]=='O') board[i][j]='X'; else if(board[i][j]=='H') board[i][j]='O'; &#125; &#125; 5，太平洋和大西洋的水Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the “Pacific ocean” touches the left and top edges of the matrix and the “Atlantic ocean” touches the right and bottom edges.Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.Note:The order of returned grid coordinates does not matter.Both m and n are less than 150.Example:Given the following 5x5 matrix: Pacific ~ ~ ~ ~ ~ ~ 1 2 2 3 (5) ~ 3 2 3 (4) (4) ~ 2 4 (5) 3 1 ~ (6) (7) 1 4 5 ~ (5) 1 1 2 4 * * * * * * Atlantic Return:[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).12345678910111213141516171819202122232425262728293031323334353637383940void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; matrix,int i ,int j, vector&lt;vector&lt;int&gt;&gt;&amp; flag)&#123; if(i&lt;0||i&gt;=matrix.size()||j&lt;0||j&gt;=matrix[0].size()||flag[i][j]) return; flag[i][j]=1; if(i+1&lt;matrix.size()&amp;&amp;matrix[i][j]&lt;=matrix[i+1][j]) dfs(matrix,i+1,j,flag); if(i-1&gt;=0&amp;&amp;matrix[i][j]&lt;=matrix[i-1][j]) dfs(matrix,i-1,j,flag); if(j-1&gt;=0&amp;&amp;matrix[i][j]&lt;=matrix[i][j-1]) dfs(matrix,i,j-1,flag); if(j+1&lt;matrix[0].size()&amp;&amp;matrix[i][j]&lt;=matrix[i][j+1]) dfs(matrix,i,j+1,flag);&#125;vector&lt;pair&lt;int, int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; /** 要能流水，则从外到里是增加的 能流到外面，则从外面开始找连通到里面的区域，且是递增 两者都能流，则取交集 */ vector&lt;pair&lt;int, int&gt;&gt; result; if(matrix.empty()) return result; vector&lt;vector&lt;int&gt;&gt; pflag(matrix.size(),vector&lt;int&gt;(matrix[0].size(),0)); vector&lt;vector&lt;int&gt;&gt; aflag(matrix.size(),vector&lt;int&gt;(matrix[0].size(),0)); for(int i=0;i&lt;matrix.size();i++) &#123; dfs(matrix,i,0,pflag); dfs(matrix,i,matrix[0].size()-1,aflag); &#125; for(int j=0;j&lt;matrix[0].size();j++) &#123; dfs(matrix,0,j,pflag); dfs(matrix,matrix.size()-1,j,aflag); &#125; for(int i=0;i&lt;matrix.size();i++) for(int j=0;j&lt;matrix[0].size();j++) if(pflag[i][j]&amp;&amp;aflag[i][j]) result.push_back(make_pair(i,j)); return result;&#125; 关于回溯，是dfs的一种，不同的是在dfs的时候发现不满足条件会回退遍历 6，电话号码的字母组合给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。示例:输入：”23”输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].说明:尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。123456789101112131415161718192021222324252627//0 1不对应数字vector&lt;string&gt; letters=&#123;" "," ","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"&#125;;void dfs(vector&lt;string&gt;&amp; result, string digits, string temp, int curr)&#123; if(curr == digits.size()) &#123; result.push_back(temp); return; &#125; for(int i=0;i&lt;letters[digits[curr]-'0'].size();i++) &#123; temp.push_back(letters[digits[curr]-'0'][i]); dfs(result, digits, temp, curr+1); temp.pop_back(); &#125;&#125;vector&lt;string&gt; letterCombinations(string digits) &#123;/**根据数字映射遍历*/ vector&lt;string&gt; result; if(digits.empty()) return result; string temp; dfs(result,digits,temp,0); return result;&#125; ###ip地址空着 ## 7，单词搜索给定一个二维网格和一个单词，找出该单词是否存在于网格中。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。示例:board =[ [‘A’,’B’,’C’,’E’], [‘S’,’F’,’C’,’S’], [‘A’,’D’,’E’,’E’]]给定 word = “ABCCED”, 返回 true.给定 word = “SEE”, 返回 true.给定 word = “ABCB”, 返回 false.来源： https://leetcode-cn.com/problems/word-search/description/12345678910111213141516171819202122232425262728bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word,vector&lt;vector&lt;int&gt;&gt;&amp; flag, int i, int j, int curr)&#123; if(curr == word.size()) return true; if(i&lt;0||i&gt;=board.size()||j&lt;0||j&gt;=board[0].size()||flag[i][j]==1||board[i][j]!=word[curr]) return false; flag[i][j] =1; if(dfs(board,word,flag,i+1,j,curr+1)|| dfs(board,word,flag,i-1,j,curr+1)|| dfs(board,word,flag,i,j+1,curr+1)|| dfs(board,word,flag,i,j-1,curr+1)) return true; flag[i][j] =0; return false;&#125;bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; /** 典型的回溯,访问路径需要标记*/ if(board.empty()) return false; if(word.empty()) return true; vector&lt;vector&lt;int&gt;&gt; flag(board.size(), vector&lt;int&gt;(board[0].size(), 0)); for(int i=0;i&lt;board.size();i++) for(int j=0;j&lt;board[0].size();j++) if(dfs(board, word,flag, i,j,0)) return true; return false;&#125; 8，二叉树的所有路径这种求所有路径的问题，通过dfs加回溯可以遍历到所有的路径给定一个二叉树，返回从根节点到叶节点的所有路径。例如，给定以下二叉树: 1 / \2 3 \ 5所有根到叶路径是: [“1-&gt;2-&gt;5”, “1-&gt;3”]123456789101112131415161718192021222324252627void dfs(TreeNode* root,vector&lt;string&gt;&amp; result, string path)&#123; if(root==NULL) return; if(root-&gt;left==NULL&amp;&amp;root-&gt;right==NULL) &#123; path+=to_string(root-&gt;val); //这里关于字符串拼接的时候遇到一些以前Java没有遇到的问题 result.push_back(path); return; &#125; path+=to_string(root-&gt;val); path+="-&gt;"; dfs(root-&gt;left,result,path); dfs(root-&gt;right,result,path); path.pop_back();&#125;vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;/**dfs加回溯可以深度遍历到所有的路径*/ vector&lt;string&gt; result; if(root==NULL) return result; string path; dfs(root,result,path); return result;&#125; 9，全排列排列和组合一直都是dfs回溯的经典类型本题是一个没有重复数字的简单版本，这里用swap版本的和一般的不用swap的回溯实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 /** void swap(int &amp;a, int &amp;b) &#123; int temp =a; a = b; b= temp; &#125; void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt; nums,int curr) &#123; if(curr ==nums.size()) &#123; result.push_back(nums); return; &#125; for(int i= curr;i&lt;nums.size();i++)&#123; swap(nums[i], nums[curr]); dfs(result,nums,curr+1); swap(nums[i], nums[curr]); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; /** 排列组合一直是dfs回溯的经典题型 题目说了是没有重复的数字进行全排列，所以这是一个不需要去重复的版本 *//* vector&lt;vector&lt;int&gt;&gt; result; if(nums.empty()) return result; dfs(result,nums,0); return result; &#125;*/ void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt; nums,vector&lt;int&gt; temp,vector&lt;int&gt;&amp; flag) &#123; if(temp.size() ==nums.size()) &#123; result.push_back(temp); return; &#125; for(int i= 0;i&lt;nums.size();i++) &#123; if(flag[i]) continue; flag[i] =1; temp.push_back(nums[i]); dfs(result,nums,temp,flag); temp.pop_back(); flag[i]=0; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; /** 排列组合一直是dfs回溯的经典题型 */ vector&lt;vector&lt;int&gt;&gt; result; if(nums.empty()) return result; vector&lt;int&gt; temp; vector&lt;int&gt; flag(nums.size(),0);//不swap的时候需要标记位 dfs(result,nums,temp,flag); return result; &#125; 10，全排列||给定一个可包含重复数字的序列，返回所有不重复的全排列。示例:输入: [1,1,2]输出:[ [1,1,2], [1,2,1], [2,1,1]]这题与上面不同之处在于原始数据可能有重复的数字这题遇到一些小坑：1，关于要不要引号的问题，如果是没有重复数字，加不加引号测试都没影响， 但是有重复数字的时候： &gt;如果是swap方法，则一定不能用第二次swap且不能要引号，且一定要排序； &gt;一般dfs的话，一定要排序，123456789101112131415161718192021222324252627282930313233 /*void swaps(int&amp; a, int&amp; b)//std中有swap函数&#123; int temp =a; a=b; b=temp;&#125;//void swapdfs(vector&lt;int&gt; nums, vector&lt;vector&lt;int&gt;&gt;&amp; result, int curr)//nums不要加&amp;，这里卡了好久&#123; if(curr &gt;= nums.size()) &#123; result.push_back(nums); return; &#125; for(int i=curr;i&lt;nums.size();i++) &#123; if(i&gt;curr&amp;&amp;nums[i]==nums[curr]) continue; swaps(nums[i],nums[curr]); swapdfs(nums,result,curr+1); //swaps(nums[i],nums[curr]); 一定不能要第二次swap &#125;&#125;vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; result; if(nums.empty()) return result; sort(nums.begin(),nums.end());//排序不可少 swapdfs(nums,result,0); return result;&#125;*/ 再看看非swap方式的123456789101112131415161718192021222324252627282930void swapdfs1(vector&lt;int&gt; nums, vector&lt;vector&lt;int&gt;&gt;&amp; result,vector&lt;int&gt;&amp; flag,vector&lt;int&gt; temp)&#123; if(temp.size() &gt;= nums.size()) &#123; result.push_back(temp); return; &#125; for(int i=0;i&lt;nums.size();i++) &#123; if(i&gt;0&amp;&amp;nums[i]==nums[i-1]&amp;&amp;!flag[i-1]) continue; if(flag[i]) continue; flag[i] =1; temp.push_back(nums[i]); swapdfs1(nums,result,flag,temp); temp.pop_back(); flag[i] =0; &#125;&#125;vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; result; if(nums.empty()) return result; sort(nums.begin(),nums.end());//排序不可少 vector&lt;int&gt; flag(nums.size(),0); vector&lt;int&gt; temp; swapdfs1(nums,result,flag,temp); return result;&#125; 11，组合给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。示例:输入: n = 4, k = 2输出:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],]这题是简答的组合，不需要组合12345678910111213141516171819202122232425void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt; temp,int curr, int n ,int k)&#123; if(k==0) &#123; result.push_back(temp); return; &#125; for(int i=curr;i&lt;=n;i++) &#123; temp.push_back(i); dfs(result,temp,i+1,n,k-1); temp.pop_back(); &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;/**组合的话，也是和排列一样用经典的dfs，不需要用swap之类的*/ vector&lt;vector&lt;int&gt;&gt; result; if(n&lt;=0||k&lt;=0) return result; vector&lt;int&gt; temp; dfs(result,temp,1,n,k); return result;&#125; 12，组合总和给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的数字可以无限制重复被选取说明：所有数字（包括 target）都是正整数。解集不能包含重复的组合。示例 1:given candidate set [2, 3, 6, 7] and target 7,A solution set is:[[7],[2, 2, 3]]given candidate set [2, 3, 5] and target 8,A solution set is:[[2,2,2,2],[2, 3, 3],[3,5]]这里是组合内可由重复数字，因此下次dfs是从i开始不是i+1123456789101112131415161718192021222324252627282930void dfs(vector&lt;int&gt; candidates, vector&lt;vector&lt;int&gt;&gt;&amp; result,vector&lt;int&gt; temp, int target, int curr)&#123; if(target==0) &#123; result.push_back(temp); return; &#125; if(curr&gt;=candidates.size()) return; for(int i=curr;i&lt;candidates.size();i++) &#123; if(target&gt;=candidates[i])//记得判断这个，不然下面的i会死循环 &#123; temp.push_back(candidates[i]); dfs(candidates,result,temp,target-candidates[i],i); temp.pop_back(); &#125; &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; /** dfs回溯*/vector&lt;vector&lt;int&gt;&gt; result; if(candidates.empty()) return result; vector&lt;int&gt; temp; dfs(candidates,result,temp,target,0); return result;&#125; 13，组合总和||给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的每个数字在每个组合中只能使用一次。说明：所有数字（包括目标数）都是正整数。解集不能包含重复的组合。示例 1:given candidate set [10,1,2,7,6,1,5] and target 8,A solution set is:[[1,7],[1, 2, 5],[2,6],[1,1,6]] given candidate set [2,5, 2, 1,2] and target 7,A solution set is:[[7],[2, 2, 3]]123456789101112131415161718192021222324252627282930void dfs(vector&lt;int&gt;&amp; candidates, vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt; temp,int curr, int target)&#123; if(target==0) &#123; result.push_back(temp); return; &#125; for(int i=curr;i&lt;candidates.size();i++) &#123; if(target&gt;=candidates[i]) &#123; temp.push_back(candidates[i]); dfs(candidates,result,temp,i+1,target-candidates[i]); temp.pop_back(); while(i+1&lt;candidates.size()&amp;&amp;candidates[i]==candidates[i+1]) i++;//做递归的重复，这里用来消除重复，当然前面是得排完序的 &#125; &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; /** 这题与组合I不同的在于这里的数字不能重复，建议可以排序下 */ vector&lt;vector&lt;int&gt;&gt; result; if(candidates.empty()) return result; sort(candidates.begin(), candidates.end()); vector&lt;int&gt; temp; dfs(candidates,result,temp,0,target); return result;&#125; 14，组合总和III找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有1 - 9的正整数，并且每种组合中不存在重复的数字。说明：所有数字都是正整数。解集不能包含重复的组合。示例 1:输入： k=3, n=7输出：[[1,2,4]]输入： k=3, n=9输出：[[1,2,6],[1,3,5],[2,3,4]]123456789101112131415161718192021222324252627void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt; temp, int k,int n,int curr)&#123; if(k==temp.size()&amp;&amp;n==0) &#123; result.push_back(temp); return; &#125; if(n&lt;0) return; for(int i=curr;i&lt;=9;i++) &#123; temp.push_back(i); dfs(result,temp,k,n-i,i+1); temp.pop_back(); &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123; /** 这题和最开始的组合差不多，多了个n*/ vector&lt;vector&lt;int&gt;&gt; result; if(n&lt;=0||k&lt;=0) return result; vector&lt;int&gt; temp; dfs(result,temp,k,n,1); return result;&#125; 15，子集给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。示例:输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []]1234567891011121314151617181920212223242526void dfs(vector&lt;int&gt; nums, vector&lt;vector&lt;int&gt;&gt;&amp; result,vector&lt;int&gt; temp,int len, int curr)&#123; if(temp.size()==len) &#123; result.push_back(temp); return; &#125; for(int i=curr;i&lt;nums.size();i++) &#123; temp.push_back(nums[i]); dfs(nums,result,temp,len,i+1); temp.pop_back(); &#125;&#125;vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; /** 子集就是不重复的组合 */ vector&lt;vector&lt;int&gt;&gt; result; if(nums.empty()) return result; vector&lt;int&gt; temp; for(int i=0;i&lt;=nums.size();i++) dfs(nums,result,temp,i,0); return result;&#125; 16，子集II给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。示例:输入: [1,2,2]输出:[ [2], [1], [1,2,2], [2,2], [1,2], []]12345678910111213141516171819202122232425262728void dfs(vector&lt;int&gt; nums, vector&lt;vector&lt;int&gt;&gt;&amp; result,vector&lt;int&gt; temp,int len, int curr)&#123; if(temp.size()==len) &#123; result.push_back(temp); return; &#125; for(int i=curr;i&lt;nums.size();i++) &#123; temp.push_back(nums[i]); dfs(nums,result,temp,len,i+1); temp.pop_back(); while(i+1&lt;nums.size()&amp;&amp;nums[i]==nums[i+1]) i++;//专门去重复的，前提是排序了的 &#125;&#125;vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;/**这题和上面不同之处在于nums中是有重复的*/ vector&lt;vector&lt;int&gt;&gt; result; if(nums.empty()) return result; vector&lt;int&gt; temp; sort(nums.begin(), nums.end()); for(int i=0;i&lt;=nums.size();i++) dfs(nums,result,temp,i,0); return result;&#125; 17，分割回文串给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。返回 s 所有可能的分割方案。示例:输入: “aab”输出:[ [“aa”,”b”], [“a”,”a”,”b”]]123456789101112131415161718192021222324252627282930313233343536373839 vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;bool huiwen(string s,int left,int right) &#123; while(left&lt;right) &#123; if(s[left++]!=s[right--]) return false; &#125; return true; &#125; void dfs(string s,vector&lt;vector&lt;string&gt;&gt;&amp; result,vector&lt;string&gt; temp,int curr) &#123; if(curr == s.size()) &#123; result.push_back(temp); return; &#125; for(int i=curr;i&lt;s.size();i++) &#123; if(huiwen(s,curr,i)) &#123; temp.push_back(s.substr(curr,i-curr+1)); dfs(s,result,temp,i+1); temp.pop_back(); &#125; &#125; &#125; vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123; /** 基本的遍历 */ vector&lt;vector&lt;string&gt;&gt; result; if(s.empty()) return result; vector&lt;string&gt; temp; dfs(s,result,temp,0); return result; &#125; &#125; 18，解数独编写一个程序，通过已填充的空格来解决数独问题。一个数独的解法需遵循如下规则：数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。空白格用 ‘.’ 表示。一个数独。答案被标成红色。Note:给定的数独序列只包含数字 1-9 和字符 ‘.’ 。你可以假设给定的数独只有唯一解。给定数独永远是 9x9 形式来源： https://leetcode-cn.com/problems/sudoku-solver/description/123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board,vector&lt;vector&lt;int&gt;&gt;&amp; row,vector&lt;vector&lt;int&gt;&gt;&amp; col,vector&lt;vector&lt;int&gt;&gt;&amp; grid)&#123; for(int i=0;i&lt;board.size();i++) &#123; for(int j=0;j&lt;board[0].size();j++) &#123; if(board[i][j]=='.') &#123; for(int val =1;val&lt;=9;val++) &#123; if(!row[i][val-1]&amp;&amp;!col[val-1][j]&amp;&amp;!grid[i/3*3+j/3][val-1]) &#123; board[i][j] = val+'0'; row[i][val-1]=1; col[val-1][j]=1; grid[i/3*3+j/3][val-1]=1; if(dfs(board,row,col,grid)) return true; board[i][j] ='.'; row[i][val-1]=0; col[val-1][j]=0; grid[i/3*3+j/3][val-1]=0; &#125; &#125; return false; &#125; &#125; &#125; return true;&#125;void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;/**dfs加标记位*/ vector&lt;vector&lt;int&gt;&gt; row(board.size(),vector&lt;int&gt;(board[0].size(),0)); vector&lt;vector&lt;int&gt;&gt; col(board.size(),vector&lt;int&gt;(board[0].size(),0)); vector&lt;vector&lt;int&gt;&gt; grid(board.size(),vector&lt;int&gt;(board[0].size(),0)); for(int i=0;i&lt;board.size();i++) &#123; for(int j=0;j&lt;board[0].size();j++) &#123; if(board[i][j]=='.') continue; int val = board[i][j] - '0'; row[i][val-1]=1; col[val-1][j]=1; grid[i/3*3+j/3][val-1]=1; &#125; &#125; dfs(board,row,col,grid);&#125; 19，n皇后n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。上图为 8 皇后问题的一种解法。给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556bool check(vector&lt;int&gt;&amp; place, int curr,int val)&#123; for(int i=0;i&lt;curr;i++) &#123; if(place[i]==val||std::abs(i-curr)==std::abs(place[i]-val)) return false; &#125; return true;&#125;void dfs(vector&lt;vector&lt;string&gt;&gt;&amp; result, vector&lt;int&gt;&amp; place, int n,int curr)&#123; if(curr ==n) &#123; vector&lt;string&gt; temp; for(int row =0;row&lt;n;row++) &#123; string tempStr; for(int col =0;col&lt;n;col++) &#123; if(place[row]==col) &#123; tempStr.push_back('Q'); &#125; else &#123; tempStr.push_back('.'); &#125; &#125; temp.push_back(tempStr); &#125; result.push_back(temp); return; &#125; for(int val =0;val&lt;n;val++) &#123; place[curr] = val; if(check(place,curr,val)) dfs(result,place,n,curr+1); place[curr] = -1; &#125;&#125;vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; /**n皇后的意思是行列都只能有一个，且对角线不能有超过两个这里也需要对行列以及对角线进行标记*/ vector&lt;vector&lt;string&gt;&gt; result; if(n==0) return result; //vector&lt;vector&lt;char&gt;&gt; nums(n,vector&lt;char&gt;(n,'.')); //vector&lt;int&gt; row(n,0); // vector&lt;int&gt; col(n,0); vector&lt;int&gt; place(n,-1); dfs(result,place,n,0); return result;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS与回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双指针]]></title>
    <url>%2F2018%2F06%2F03%2F%E5%8F%8C%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[双指针的应用场景比较明显。 1，两数之和||-输入有序数组 2，平方数之和 3，反转字符串中的元音字母 4，验证回文字符串|| 5，合并两个有序数组 6，环形链表 7，单词中的最长子序列 1，两数之和||-输入有序数组给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。说明:返回的下标值（index1 和 index2）不是从零开始的。你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。示例:输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。123456789101112131415161718192021222324vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;/**思路：左右夹(题目说了有且仅有唯一的答案，那就少了一些判断了)*/ int left = 0 , right = numbers.size()-1; vector&lt;int&gt; result(2); while(left&lt;right) &#123; if(numbers[left]+numbers[right] == target) break; if(numbers[left]+numbers[right] &lt; target) &#123; left++; &#125; else &#123; right--; &#125; &#125; //因为说了有唯一的解，这里就不判断了 result[0] = left+1; result[1] = right+1; return result;&#125; 2，平方数之和给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c。示例1:输入: 5输出: True解释: 1 1 + 2 2 = 5示例2:输入: 3输出: False12345678910111213141516bool judgeSquareSum(int c) &#123; /** 也是左右夹 */ int left = 0 ,right = sqrt(c);//这里还是加上sqrt好 while(left&lt;=right) &#123; if(left*left+right*right == c) return true; else if(left*left+right*right &lt; c) left++; else right--; &#125; return false; &#125; 3，反转字符串中的元音字母编写一个函数，以字符串作为输入，反转该字符串中的元音字母。示例 1：给定 s = “hello”, 返回 “holle”.示例 2：给定 s = “leetcode”, 返回 “leotcede”.注意:元音字母不包括 “y”.1234567891011121314151617181920212223242526272829bool check(char c1) &#123; char cc[] =&#123;'a','e','i','o','u','A','E','I','O','U'&#125;; for(auto temp:cc) &#123; if(temp == c1) return true; &#125; return false; &#125; string reverseVowels(string s) &#123; int left = 0 ,right = s.size()-1; while(left&lt;right) &#123; while(left&lt;right&amp;&amp;!check(s[left])) left++; while(left&lt;right&amp;&amp;!check(s[right])) right--; if(left&lt;right) &#123; char temp = s[left]; s[left] = s[right]; s[right] = temp; left++; right--; &#125; &#125; return s; &#125; 4，验证回文字符串||给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。示例 1:输入: “aba”输出: True示例 2:输入: “abca”输出: True解释: 你可以删除c字符。注意:字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。12345678910111213141516171819202122232425bool check(string s,int left, int right) &#123; while(left&lt;right) &#123; if(s[left]!=s[right]) return false; left++; right--; &#125; return true; &#125; bool validPalindrome(string s) &#123; /** 最多删一个字符，，所以可以两边夹 */ int left =0, right =s.length()-1; while(left&lt;right) &#123; if(s[left]!=s[right]) return check(s,left+1,right)||check(s,left,right-1); left++; right--; &#125; return true; &#125; 5，合并两个有序数组给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。说明:初始化 nums1 和 nums2 的元素数量分别为 m 和 n。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。示例:输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出: [1,2,2,3,5,6]来源： https://leetcode-cn.com/problems/merge-sorted-array/description/1234567891011121314151617181920void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; /** 从后面排序移动的会更少 */ int index = m+n-1; m--; n--; while(m&gt;=0&amp;&amp;n&gt;=0) &#123; if(nums1[m]&gt;nums2[n]) nums1[index--] = nums1[m--]; else nums1[index--] = nums2[n--]; &#125; while(n&gt;=0) &#123; nums1[n]=nums2[n]; n--; &#125; &#125; 6，环形链表给定一个链表，判断链表中是否有环。进阶：你能否不使用额外空间解决此题？123456789101112131415bool hasCycle(ListNode *head) &#123; /** 快慢指针 */ if(head == NULL|| head-&gt;next == NULL) return false; ListNode* left =head,*right=head-&gt;next; while(left!=NULL&amp;&amp;right!=NULL&amp;&amp;right-&gt;next!=NULL) &#123; if(left == right) return true; left=left-&gt;next; right=right-&gt;next-&gt;next; &#125; return false; &#125; 7，单词中的最长子序列Input:s = “abpcplea”, d = [“ale”,”apple”,”monkey”,”plea”]Output:“apple”题目描述：删除 s 中的一些字符，使得它构成字符串列表 d 中的一个字符串，找出能构成的最长字符串。如果有多个相同长度的结果，返回按字典序排序的最大字符串。12345678910111213141516171819202122232425262728string findLongestWord(string s, vector&lt;string&gt;&amp; d) &#123; /** 原本想的是d排序，然后在s中查找是否存在该序列 */ auto comp = [](const string&amp; p1, const string&amp; p2)&#123; return p1.length()&gt;p2.length()?true:(p1.length()==p2.length()?p1&lt;p2:false); &#125;; sort(d.begin(), d.end(), comp); for(auto&amp; temp : d) &#123; int indexs=0,indext=0; while(indexs&lt;s.size()&amp;&amp;indext&lt;temp.size()) &#123; if(s[indexs]==temp[indext]) &#123; indexs++; indext++; &#125; else &#123; indexs++; &#125; &#125; if(indext==temp.size()) return temp; &#125; return ""; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法]]></title>
    <url>%2F2018%2F06%2F03%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[贪心算法是保证局部最优，最终的结果是全局最优解 1 分发饼干 2 买卖股票的最佳时机 3 种花问题 4 非递减数列 5 判断子序列 6 用最少数量的箭刺破气球 7 划分字母区间 8 根据身高重建队列 1 分发饼干假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。注意：你可以假设胃口值为正。一个小朋友最多只能拥有一块饼干。示例 1:输入: [1,2,3], [1,1]输出: 1解释:你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。示例 2:输入: [1,2], [1,2,3]输出: 2解释:你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2.来源： https://leetcode-cn.com/problems/assign-cookies/description/123456789101112131415int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123; /**思路：这题将所有排序，然后一个个比较应该就可以 */ sort(g.begin(),g.end());sort(s.begin(), s.end());int indexG = 0,indexS=0;while(indexG &lt; g.size()&amp;&amp;indexS&lt;s.size())&#123; if(g[indexG]&lt;=s[indexS]) indexG++; indexS++; &#125;return indexG;&#125; 2 买卖股票的最佳时机给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。示例 1:输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。示例 2:输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。示例 3:输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。123456789101112131415int maxProfit(vector&lt;int&gt;&amp; prices) &#123; /** 思路：这题保证局部最优最后的结果应该是最优，因为不能连续买或者卖，每次只要保证前后就可以了 */ int result =0,index=1; while(index&lt;prices.size()) &#123; if(prices[index]&gt;prices[index-1]) &#123; result+=prices[index]-prices[index-1]; &#125; index++; &#125; return result;&#125; 3 种花问题假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。示例 1:输入: flowerbed = [1,0,0,0,1], n = 1输出: True示例 2:输入: flowerbed = [1,0,0,0,1], n = 2输出: False注意:数组内已种好的花不会违反种植规则。输入的数组长度范围为 [1, 20000]。n 是非负整数，且不会超过输入数组的大小。1234567891011121314151617181920212223bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) &#123; /** 思路：种花的话，保证前后和本身为0的就可以种，最后看全局剩下的结果 */ int index =0; while(index&lt;flowerbed.size()) &#123; if(flowerbed[index]==1) &#123; index++; continue; &#125; int pre = index==0?0:flowerbed[index-1]; int next = index == flowerbed.size()-1?0:flowerbed[index+1]; if(!pre&amp;&amp;!next) &#123; n--; flowerbed[index]=1; &#125; index++; &#125;return n&lt;=0;&#125; 4 非递减数列给定一个长度为 n 的整数数组，你的任务是判断在最多改变 1 个元素的情况下，该数组能否变成一个非递减数列。我们是这样定义一个非递减数列的： 对于数组中所有的 i (1 &lt;= i &lt; n)，满足 array[i] &lt;= array[i + 1]。示例 1:输入: [4,2,3]输出: True解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。示例 2:输入: [4,2,1]输出: False解释: 你不能在只改变一个元素的情况下将其变为非递减数列。说明: n 的范围为 [1, 10,000]。123456789101112131415161718192021 bool checkPossibility(vector&lt;int&gt;&amp; nums) &#123; /** 思路：原来的思想是只比较前后两个，后面小就加一，但是发现若后面index+1比前面index-1还小的情况，因此重新考虑这里将数组进行替换操作，[index]&lt;[index-1]的时候，一般是考虑将[index-1]=[index],不然反过来的话后面的值会变大，这样可能会影响后面的顺序；还有特殊情况[index]&lt;[index-1] [index]&lt;[index-2],这样的话只有[index]=[index-1]了 */ int index =1,count=0; while(index&lt;nums.size()) &#123; if(nums[index]&lt;nums[index-1]) &#123; if(index-2&gt;=0&amp;&amp;nums[index]&lt;nums[index-2]) nums[index] = nums[index-1];//后一个值变大 else nums[index-1]=nums[index];//前一个值变小 count++; &#125; index++; &#125;return count&lt;=1; &#125; 5 判断子序列给定字符串 s 和 t ，判断 s 是否为 t 的子序列。你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。示例 1:s = “abc”, t = “ahbgdc”返回 true.示例 2:s = “axc”, t = “ahbgdc”返回 false.后续挑战 :如果有大量输入的 S，称作S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？123456789101112131415bool isSubsequence(string s, string t) &#123; /** 这里是判断子序列，区分于子串 判断的时候以s作为基准就好了 */ if(s.size()==0) return true; int i = 0,j=0; while(i&lt;s.size()&amp;&amp;j&lt;t.size()) &#123; if(s[i]==t[j]) i++; j++; &#125; return i&gt;=s.size();&#125; 6 用最少数量的箭刺破气球在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以y坐标并不重要，因此只要知道开始和结束的x坐标就足够了。开始坐标总是小于结束坐标。平面内最多存在104个气球。一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。Example:输入:[[10,16], [2,8], [1,6], [7,12]]输出:2解释:对于该样例，我们可以在x = 6（射爆[2,8],[1,6]两个气球）和 x = 11（射爆另外两个气球）。来源： https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/description/12345678910111213141516171819202122232425static bool comp(pair&lt;int,int&gt; p1,pair&lt;int,int&gt; p2) &#123; return p1.second&lt;=p2.second; //这里只用终点排序就行，不用关注起点 &#125;int findMinArrowShots(vector&lt;pair&lt;int, int&gt;&gt;&amp; points) &#123; /** 这种关于活动选择的问题，其变形还有关于参加活动的起始与结束时间 其实可以按照终点对气球进行排序即可，终点重合的算一个 */ if(points.size()==0) return 0; int result =1; sort(points.begin(),points.end(),comp); pair&lt;int,int&gt; temp = points[0]; int index =1; while(index&lt;points.size()) &#123; if(points[index].first &gt; temp.second) &#123; result++; temp = points[index]; &#125; index++; &#125; return result; &#125; 7 划分字母区间字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。示例 1:输入: S = “ababcbacadefegdehijhklij”输出: [9,7,8]解释:划分结果为 “ababcbaca”, “defegde”, “hijhklij”。每个字母最多出现在一个片段中。像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。注意:S的长度在[1, 500]之间。S只包含小写字母’a’到’z’。12345678910111213141516171819202122232425262728vector&lt;int&gt; partitionLabels(string S) &#123;/**思路：贪心法保证局部最小就行，这样就能分的最多要保证分的最小，则每次得关注片段里面的字符在右边没有出现过开始以最左边的开始，肯定是第一个片段*/ vector&lt;int&gt; result,finalIndex(26,0);int left =0;for(int i=0; i&lt;S.size(); i++)&#123; finalIndex[S[i]-'a'] = i;//记录最后一个的索引&#125;while(left&lt;S.size())&#123; int right = finalIndex[S[left]-'a']; for(int k = left;k&lt;=right;k++) &#123; if(finalIndex[S[k]-'a']&gt;right) &#123; right = finalIndex[S[k]-'a']; continue; &#125; &#125; result.push_back(right-left+1); left=right+1;&#125;return result;&#125; 8 根据身高重建队列假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。注意：总人数少于1100人。示例输入:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]输出:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]来源： https://leetcode-cn.com/problems/queue-reconstruction-by-height/description/1234567891011121314151617vector&lt;pair&lt;int, int&gt;&gt; reconstructQueue(vector&lt;pair&lt;int, int&gt;&gt;&amp; people) &#123;/**队列的插入规则先按照高的插入，这样低的插入后不会改变已经插入的k值；若有相同高度，则按照k值递增插入*/ auto comp = [](const pair&lt;int, int&gt;&amp; p1, const pair&lt;int, int&gt;&amp; p2)&#123; return (p1.first&gt;p2.first)||(p1.first==p2.first&amp;&amp;p1.second&lt;p2.second); &#125;;sort(people.begin(), people.end(), comp);vector&lt;pair&lt;int,int&gt;&gt; result;for(pair&lt;int,int&gt; p:people)&#123; //注意Insert方法，会移动里面已有的元素 result.insert(result.begin()+p.second, p);//按照first排完序后，second就是相对的要插入的索引&#125; return result;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于二分查找算法]]></title>
    <url>%2F2018%2F06%2F03%2F%E5%85%B3%E4%BA%8E%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[二分查找是常见算法。 1，x 的平方根 2，排列硬币 3，寻找比目标字母大的最小字母 4，有序数组的 Single Element 5，第一个错误的版本 6，旋转数组的最小数字 7，查找区间 1，x 的平方根实现 int sqrt(int x) 函数。计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。示例 1:输入: 4输出: 2示例 2:输入: 8输出: 2说明: 8 的平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去1234567891011121314151617181920int mySqrt(int x) &#123;/** 思路：二分法，比较mid 与x/mid的值，当mid&lt; x/mid的时候，保留右边。 这里不写成mid*mid与x进行比较的原因是防止溢出 */ if(x&lt;=1) return x; int left = 1,right =x/2; while(left&lt;=right) &#123; int mid = left+(right -left)/2; int temp = x/mid; if (mid == temp) return mid; if( mid &gt; temp) right = mid -1; else left = mid +1; &#125; return right;&#125; 2，排列硬币你总共有 n 枚硬币，你需要将它们摆成一个阶梯形状，第 k 行就必须正好有 k 枚硬币。给定一个数字 n，找出可形成完整阶梯行的总行数。n 是一个非负整数，并且在32位有符号整型的范围内。示例 1:n = 5硬币可排列成以下几行:¤¤ ¤¤ ¤因为第三行不完整，所以返回2.示例 2:n = 8硬币可排列成以下几行:¤¤ ¤¤ ¤ ¤¤ ¤因为第四行不完整，所以返回3.来源： https://leetcode-cn.com/problems/arranging-coins/description/12345678910111213141516171819int arrangeCoins(int n) &#123; /** 二分查找：和(1+x)x/2 与n进行比较 */ if(n&lt;=1) return n; int left = 1, right = n; ///这里的int在Leetcode中过不了大数据用例，全改为long while(left &lt;= right) &#123; int mid = left + (right - left)/2; int sum=(mid+1)*mid/2; if(sum == x) return mid; if(sum &gt; x) right = mid -1; else left = mid+1; &#125;return right;&#125; 当然还有不用二分法，简单的循环12345678910111213141516 int arrangeCoins(int n) &#123;/** int level = 1; while(n&gt;0) &#123; n-=level++; &#125; return n==0?level-1:level-2; &#125;*/ int level=1; while(n&gt;=level) &#123; n-=level++; &#125; return level-1; &#125; 3，寻找比目标字母大的最小字母给定一个只包含小写字母的有序数组letters 和一个目标字母 target，寻找有序数组里面比目标字母大的最小字母。数组里字母的顺序是循环的。举个例子，如果目标字母target = ‘z’ 并且有序数组为 letters = [‘a’, ‘b’]，则答案返回 ‘a’。示例:输入:letters = [“c”, “f”, “j”]target = “a”输出: “c”输入:letters = [“c”, “f”, “j”]target = “c”输出: “f”输入:letters = [“c”, “f”, “j”]target = “d”输出: “f”输入:letters = [“c”, “f”, “j”]target = “g”输出: “j”输入:letters = [“c”, “f”, “j”]target = “j”输出: “c”输入:letters = [“c”, “f”, “j”]target = “k”输出: “c”注:letters长度范围在[2, 10000]区间内。letters 仅由小写字母组成，最少包含两个不同的字母。目标字母target 是一个小写字母。1234567891011121314151617char nextGreatestLetter(vector&lt;char&gt;&amp; letters, char target)&#123; /** 大于target的数有很多，这里只需要找到第一个大于的就行 等效于找到最后一个小于等于target的数 */ int left = 0, right = letters.size() - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (letters[mid] &lt;= target) left = mid + 1; else right = mid - 1; &#125; //因为已经说了最少包含两个不同字母，且是循环比较大小，所以最右边的left不存在就在0位 return left &gt;= letters.size() ? letters[0] : letters[left];&#125; 4，有序数组的 Single Element给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。示例 1:输入: [1,1,2,3,3,4,4,8,8]输出: 2示例 2:输入: [3,3,7,7,10,11,11]输出: 10注意: 您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。1234567891011121314151617181920int singleNonDuplicate(vector&lt;int&gt;&amp; nums)&#123; /** 思路：这种只出现一次的，最开始想到的是用位运算，但是位运算的事件复杂度是n, 题目说了是有序数组，那么就尝试二分查找，事件复杂度为logN 因为是有序，所以可等效于查找 */ int left = 0, right = nums.size() - 1; while (left &lt; right) // 这里相等的时候就是所求的值，与其他不同 &#123; int mid = left + (right - left) / 2; if (mid % 2) --mid; //保证一直是偶数位 if (nums[mid] == nums[mid + 1]) left = mid + 2; else right = mid; &#125; return nums[left]; //left==right&#125; 5，第一个错误的版本你是产品经理，目前正在领导一个团队开发一个新产品。不幸的是，您的产品的最新版本没有通过质量检查。由于每个版本都是基于之前的版本开发的，所以错误版本之后的所有版本都是不好的。假设你有 n 个版本 [1, 2, …, n]，你想找出第一个错误的版本，导致下面所有的错误。你可以通过 bool isBadVersion(version) 的接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。您应该尽量减少对 API 的调用次数。来源： https://leetcode-cn.com/problems/first-bad-version/description/12345678910111213141516int firstBadVersion(int n) &#123; /** 思路：最简单的二分查找判断 */ int left = 1, right = n; while (left &lt; right) //这里相等的时候也是最后的结果 &#123; int mid = left + (right - left) / 2; if (isBadVersion(mid)) right = mid; //与上面找有序数组的一样，注意有错的时候那位 else left = mid + 1; &#125; return left; //right==left&#125; 6，旋转数组的最小数字假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2]）。找到其中最小的元素。你可以假设数组中不存在重复元素。示例:输入: [3,4,5,1,2],输出: 112345678910111213141516171819int findMin(vector&lt;int&gt;&amp; nums) &#123; /** 思路：这题与找循环字母的那题有些类似 */ int left = 0, right = nums.size() - 1; while (left &lt; right) //left==right同样也是结束条件 &#123; if (nums[right] &gt;= nums[left]) return nums[left]; //这句话不能少，不然判断和左边判断的时候会有问题 int mid = left + (right - left) / 2; if (nums[mid] &lt; nums[left]) right = mid; else left = mid + 1; &#125;//最后的结束条件 return nums[right]; //left ==right&#125; 7，查找区间给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。你的算法时间复杂度必须是 O(log n) 级别。如果数组中不存在目标值，返回 [-1, -1]。Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4]Input: nums = [5,7,7,8,8,10], target = 6Output: [-1,-1]1234567891011121314151617181920212223242526272829vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target)&#123; vector&lt;int&gt; result(2, -1); if (nums.size() == 0) return result; int left = 0, right = nums.size() - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &gt;= target) right = mid - 1; else left = mid + 1; &#125; if (left &gt;= nums.size() || nums[left] != target) //这是与之前不同的地方，因为可能不存在，所以要判断边界与值 return result; result[0] = left; left = 0, right = nums.size() - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &lt;= target) left = mid + 1; else right = mid - 1; &#125; if (right &lt; 0 || nums[right] != target) return result; result[1] = right; return result;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于链表LinkedList]]></title>
    <url>%2F2018%2F04%2F25%2F%E5%85%B3%E4%BA%8E%E9%93%BE%E8%A1%A8LinkedList%2F</url>
    <content type="text"><![CDATA[链表的主要操作包括遍历与头插的寻找等。 1，合并两个有序链表 2，反转单链表 3，删除排序链表中的重复元素 4，删除链表中的节点 5，删除链表中的元素 6，回文链表 7，环形链表 8，相交链表 1，合并两个有序链表将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。示例：输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;412345678/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */ 1234567891011121314151617181920212223242526272829303132333435363738394041ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; /** 法一：递归 法二：循环 */ /** if(l1 == NULL) return l2; if(l2 ==NULL) return l1; if(l1-&gt;val &lt; l2-&gt;val) &#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else &#123; l2-&gt;next = mergeTwoLists(l2-&gt;next,l1); return l2; &#125; **/ if(l1 == NULL) return l2; if(l2 ==NULL) return l1; ListNode* resultList = new ListNode(-1); ListNode* temp =resultList; while(l1&amp;&amp;l2) &#123; if(l1-&gt;val &lt; l2-&gt;val) &#123; temp-&gt;next = l1; l1=l1-&gt;next; &#125; else &#123; temp-&gt;next = l2; l2 =l2-&gt;next; &#125; temp=temp-&gt;next; &#125; temp-&gt;next = l1?l1:l2; return resultList-&gt;next; &#125; 2，反转单链表进阶:链表可以迭代或递归地反转。你能否两个都实现一遍？12345678910111213ListNode* reverseList(ListNode* head) &#123; if(head == NULL || head-&gt;next == NULL) return head; ListNode* resultList = new ListNode(-1); ListNode* temp = NULL; while(head!=NULL) &#123; temp=head-&gt;next; head-&gt;next = resultList-&gt;next; resultList-&gt;next = head; head = temp; &#125; return resultList-&gt;next; &#125; 尝试用递归的方法做1234567//如果链表为空或者链表中只有一个元素 if(head ==NULL ||head-&gt;next == NULL) return head; ListNode* newHead = reverseList(head-&gt;next); head-&gt;next-&gt;next=head; head-&gt;next = NULL; return newHead; 3，删除排序链表中的重复元素给定一个排序链表，删除所有重复的元素使得每个元素只留下一个。案例：给定 1-&gt;1-&gt;2，返回 1-&gt;2给定 1-&gt;1-&gt;2-&gt;3-&gt;3，返回 1-&gt;2-&gt;3123456789101112ListNode* deleteDuplicates(ListNode* head) &#123; if(head == NULL || head-&gt;next ==NULL) return head; ListNode* p =head, *q =head; while(q !=NULL) &#123; while(q!=NULL&amp;&amp;q-&gt;val==p-&gt;val) q=q-&gt;next; p-&gt;next=q; p=p-&gt;next; &#125; return head; &#125; 4，删除链表中的节点请编写一个函数，使其可以删除某个链表中给定的（非末尾的）节点，您将只被给予要求被删除的节点。比如：假设该链表为 1 -&gt; 2 -&gt; 3 -&gt; 4 ，给定您的为该链表中值为 3 的第三个节点，那么在调用了您的函数之后，该链表则应变成 1 -&gt; 2 -&gt; 4 。1234567void deleteNode(ListNode* node) &#123; /** 题目已经说了是指定的非尾节点了 */ node-&gt;val = node-&gt;next-&gt;val; node-&gt;next = node-&gt;next-&gt;next; &#125; 5，删除链表中的元素删除链表中等于给定值 val 的所有元素。示例给定: 1 –&gt; 2 –&gt; 6 –&gt; 3 –&gt; 4 –&gt; 5 –&gt; 6, val = 6返回: 1 –&gt; 2 –&gt; 3 –&gt; 4 –&gt; 512345678910111213141516171819202122 ListNode* removeElements(ListNode* head, int val) &#123;/**主要是判断重复值是否到了最后*/ if(head == NULL) return head; ListNode* temp = new ListNode(-1); ListNode* result = temp; while(head != NULL) &#123; while(head!=NULL &amp;&amp; head-&gt;val == val) &#123; head=head-&gt;next; &#125; temp-&gt;next = head; temp =temp-&gt;next; if(head == NULL) return result-&gt;next; else head = head-&gt;next; &#125; return result-&gt;next; &#125; 6，回文链表请检查一个链表是否为回文链表。进阶：你能在 O(n) 的时间和 O(1) 的额外空间中做到吗？12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152ListNode* reversrList(ListNode* head)&#123;if(head == NULL ||head-&gt;next == NULL) return head;ListNode* result = new ListNode(-1);ListNode* temp =NULL;while(head != NULL)&#123; temp=head-&gt;next; head-&gt;next=result-&gt;next; result-&gt;next =head; head = temp;&#125;return result-&gt;next;&#125;ListNode* getMidNode(ListNode* head)&#123;//查找中间节点，奇数的话返回中间的前面一个/** 用两个指针快速查找中间点*/if(head == NULL || head-&gt;next == NULL) return head;ListNode* fast=head, *slow=head;while(fast!=NULL&amp;&amp;fast-&gt;next!=NULL&amp;&amp;fast-&gt;next-&gt;next!=NULL)&#123; fast = fast-&gt;next-&gt;next; slow=slow-&gt;next;&#125;return slow;&#125;/**检查链表是否是回文链表在O(n的时间和O(1)空间做出*/bool isPalindrome(ListNode* head) &#123; /** 思路：O(n)的时间，O(1)空间考虑是找链表中间(注意奇偶)，后半部翻转，然后和前面的比较 */ if(head == NULL ||head-&gt;next ==NULL) return true; //奇数的话从中间的一个，偶数的话是对称的前一个 ListNode* midNode = getMidNode(head); midNode-&gt;next = reversrList(midNode-&gt;next); //逐个比较 while(midNode-&gt;next!=NULL) &#123; if(head-&gt;val != midNode-&gt;next-&gt;val) return false; head = head-&gt;next; midNode = midNode-&gt;next; &#125; return true; &#125; 7，环形链表给定一个链表，判断链表中否有环。补充：你是否可以不用额外空间解决此题？123456789101112131415bool hasCycle(ListNode *head) &#123; /** 思路：有环的话单链表一般是在尾部有环，通常考虑的是快慢指针跑，看看会不会相遇 */ if(head == NULL ||head-&gt;next ==NULL) return false; ListNode * slow = head, *fast = head-&gt;next-&gt;next;//开始得先跑两步 while(fast!= NULL&amp;&amp;fast-&gt;next!=NULL&amp;&amp;slow!=NULL) &#123; if(fast == slow) return true; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; return false; &#125; 8，相交链表编写一个程序，找到两个单链表相交的起始节点。例如，下面的两个链表：A: a1 → a2 ↘ c1 → c2 → c3 ↗B: b1 → b2 → b3在节点 c1 开始相交。注意：如果两个链表没有交点，返回 null.在返回结果后，两个链表仍须保持原有的结构。可假定整个链表结构中没有循环。程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; /** 思路：相交后的节点都是相同的，在有限的时间和空间下， 两个指针，先统计两个链表的长度，长度差就是指针先跑的地方 *//** if(headA == NULL || headB == NULL) return NULL; int countA = 0, countB = 0; ListNode * tempA=headA,*tempB=headB; while(tempA-&gt;next != NULL) &#123; ++countA; tempA = tempA-&gt;next; &#125; while(tempB-&gt;next != NULL) &#123; ++countB; tempB = tempB-&gt;next; &#125; if(tempA != tempB) return NULL; tempA=headA; tempB=headB; if(countA-countB&gt;0) &#123; countA = countA-countB; while(countA&gt;0) &#123; tempA = tempA-&gt;next; --countA; &#125; &#125; else if(countA-countB&lt;0) &#123; countB = countB-countA; while(countB&gt;0) &#123; tempB = tempB-&gt;next; --countB; &#125; &#125; while(tempA!=NULL) &#123; if( tempA == tempB) return tempA; tempA=tempA-&gt;next; tempB=tempB-&gt;next; &#125; return NULL;**//**还有一种更简单的做法*/ if(headA == NULL || headB == NULL) return NULL; ListNode* l1 = headA, *l2 = headB; while(l1 != l2)&#123; l1 = (l1 == NULL) ? headB : l1-&gt;next; l2 = (l2 == NULL) ? headA : l2-&gt;next; &#125; return l1 &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新建一个hexo模版的文件]]></title>
    <url>%2F2018%2F04%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[这里只是简单的记录下一些操作，包括一些前人踩过的坑。 新建一个提交 Generate static files Run server Deploy to remote sites 遇到的问题 hexo与github page结合可以很方便的搭建出个人的静态网页博客。 新建一个提交1$ hexo new "My New Post" 在根目录而非我们自己的themes的根目录下执行上述命令，hexo会自动在根目录的_posts文件夹下面生成相关的md文件；然后打开该文件就可写我们自己的博客，具体的语法规则详见: Writing Generate static files1$ hexo generate 该命令生成静态页面至public目录详见: Generating Run server1$ hexo server hexo server 可简化为命令 hexo s，开启预览访问端口，默认是4000端口，打开浏览器访问 http://localhost:4000 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考这篇文章：http://blog.liuxianan.com/windows-port-bind.html更多信息详见: Server Deploy to remote sites1$ hexo deploy 发布过程，发布中可能需要先装一个插件1npm install hexo-deployer-git --save 详见: Deployment 最后注意中文的编码问题，保存的时候记得保存编码为”UTF-8” 遇到的问题1 一段时间没登录后，使用hexo遇到下面的问题(20181125)1/c/Users/cai/AppData/Roaming/npm/hexo: line 12: node: command not found 自己记得没有删除过hexo，网上搜了下参考，发现好像自己的node.js在开机清理垃圾的时候被删除了，于是安装了一下node.js，hexo就可以正常使用了。 具体的手把手教程可参考：https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html https://segmentfault.com/a/1190000004359502 https://blog.csdn.net/u012195214/article/details/79204088]]></content>
  </entry>
</search>
